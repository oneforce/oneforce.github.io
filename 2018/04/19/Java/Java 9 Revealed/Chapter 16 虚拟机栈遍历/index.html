<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>虚拟机栈遍历 | oneforce blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/mermaid/6.0.0/mermaid.min.css"><script src="//cdn.bootcss.com/mermaid/6.0.0/mermaid.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-113549521-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">虚拟机栈遍历</h1><a id="logo" href="/.">oneforce blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">虚拟机栈遍历</h1><div class="post-meta">Apr 19, 2018<span> | </span><span class="category"><a href="/categories/Java-9-Revealed/">Java 9 Revealed</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/04/19/Java/Java 9 Revealed/Chapter 16 虚拟机栈遍历/" href="/2018/04/19/Java/Java 9 Revealed/Chapter 16 虚拟机栈遍历/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-什么是虚拟机栈"><span class="toc-text">一. 什么是虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-什么是虚拟机栈遍历"><span class="toc-text">二. 什么是虚拟机栈遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-JDK-8-中的栈遍历"><span class="toc-text">三. JDK 8 中的栈遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-JDK-8-的栈遍历的缺点"><span class="toc-text">四. JDK 8 的栈遍历的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-JDK-9-中的栈遍历"><span class="toc-text">五. JDK 9 中的栈遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-指定遍历选项"><span class="toc-text">1. 指定遍历选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-表示一个栈帧"><span class="toc-text">2. 表示一个栈帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-获取StackWalker"><span class="toc-text">3. 获取StackWalker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-遍历栈"><span class="toc-text">4. 遍历栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-认识调用者的类"><span class="toc-text">5. 认识调用者的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-栈遍历权限"><span class="toc-text">6. 栈遍历权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-总结"><span class="toc-text">六. 总结</span></a></li></ol></div></div><div class="post-content"><p><a href="http://www.cnblogs.com/IcanFixIt/p/7238835.html" target="_blank" rel="noopener">原文地址</a></p>
<p>在本章中，主要介绍以下内容：</p>
<ul>
<li>什么是虚拟机栈（JVM Stack）和栈帧（Stack Frame）</li>
<li>如何在JDK 9之前遍历一个线程的栈</li>
<li>在JDK 9中如何使用StackWalker API遍历线程的栈</li>
<li>在JDK 9中如何获取调用者的类</li>
</ul>
<h2 id="一-什么是虚拟机栈"><a href="#一-什么是虚拟机栈" class="headerlink" title="一. 什么是虚拟机栈"></a>一. 什么是虚拟机栈</h2><p>JVM中的每个线程都有一个私有的JVM栈，它在创建线程的同时创建。 该栈是后进先出（LIFO）数据结构。 栈保存栈帧。 每次调用一个方法时，都会创建一个新的栈帧并将其推送到栈的顶部。 当方法调用完成时，栈帧销毁（从栈中弹出）。 堆栈中的每个栈帧都包含自己的局部变量数组，以及它自己的操作数栈，返回值和对当前方法类的运行时常量池的引用。 JVM的具体实现可以扩展一个栈帧来保存更多的信息。</p>
<p>JVM栈上的一个栈帧表示给定线程中的Java方法调用。 在给定的线程中，任何点只有一个栈帧是活动的。 活动栈帧被称为当前栈帧，其方法称为当前方法。 定义当前方法的类称为当前类。 当方法调用另一种方法时，栈帧不再是当前栈帧 —— 新的栈帧被推送到栈，并且执行方法成为当前方法，并且新栈帧成为当前栈帧。 当方法返回时，旧栈帧再次成为当前帧。 有关JVM栈和栈帧的更多详细信息，请参阅 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a> 上的Java虚拟机规范。</p>
<blockquote>
<p>Tips</p>
<p>如果JVM支持本地方法，则线程还包含本地方法栈，该栈包含每个本地方法调用的本地方法栈帧。</p>
</blockquote>
<p>下图显示了两个线程及其JVM栈。 第一个线程的JVM栈包含四个栈帧，第二个线程的JVM栈包含三个栈帧。 Frame 4是Thread-1中的活动栈帧，Frame 3是Thread-2中的活动栈帧。</p>
<p><img src="http://blog.oneforce.cn/images/20180419/thread_stack.png" alt></p>
<h2 id="二-什么是虚拟机栈遍历"><a href="#二-什么是虚拟机栈遍历" class="headerlink" title="二. 什么是虚拟机栈遍历"></a>二. 什么是虚拟机栈遍历</h2><p>虚拟机栈遍历是遍历线程的栈帧并检查栈帧的内容的过程。 从Java 1.4开始，可以获取线程栈的快照，并获取每个栈帧的详细信息，例如方法调用发生的类名称和方法名称，源文件名，源文件中的行号等。 栈遍历中使用的类和接口位于Stack-Walking API中。</p>
<h2 id="三-JDK-8-中的栈遍历"><a href="#三-JDK-8-中的栈遍历" class="headerlink" title="三. JDK 8 中的栈遍历"></a>三. JDK 8 中的栈遍历</h2><p>在JDK 9之前，可以使用java.lang包中的以下类遍历线程栈中的所有栈帧：</p>
<ul>
<li>Throwable</li>
<li>Thread</li>
<li>StackTraceElement</li>
</ul>
<p><code>StackTraceElement</code>类的实例表示栈帧。 <code>Throwable</code>类的<code>getStackTrace()</code>方法返回一含当前线程栈的栈帧的<code>StackTraceElement []</code>数组。 Thread类的<code>getStackTrace()</code>方法返回一个<code>StackTraceElement []</code>数组，它包含线程栈的栈帧。 数组的第一个元素是栈中的顶层栈帧，表示序列中最后一个方法调用。 JVM的一些实现可能会在返回的数组中省略一些栈帧。</p>
<p><code>StackTraceElement</code>类包含以下方法，它返回由栈帧表示的方法调用的详细信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getClassLoaderName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getFileName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getMethodName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getModuleName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getModuleVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNativeMethod</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips</p>
<p>在JDK 9中将<code>getModuleName()</code>，<code>getModuleVersion()</code>和<code>getClassLoaderName()</code>方法添加到此类中。</p>
</blockquote>
<p><code>StackTraceElement</code>类中的大多数方法都有直观的名称，例如，<code>getMethodName()</code>方法返回调用由此栈帧表示的方法的名称。 <code>getFileName()</code>方法返回包含方法调用代码的源文件的名称，getLineNumber()返回源文件中的方法调用代码的行号。</p>
<p>以下代码片段显示了如何使用Throwable和Thread类检查当前线程的栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using the Throwable class</span></span><br><span class="line">StackTraceElement[] frames = <span class="keyword">new</span> Throwable().getStackTrace();</span><br><span class="line"><span class="comment">// Using the Thread class</span></span><br><span class="line">StackTraceElement[] frames2 = Thread.currentThread()</span><br><span class="line">                                   .getStackTrace();</span><br><span class="line"><span class="comment">// Process the frames here...</span></span><br></pre></td></tr></table></figure>
<p>本章中的所有程序都是<code>com.jdojo.stackwalker</code>模块的一部分，其声明如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-info.java</span></span><br><span class="line"><span class="keyword">module</span> com.jdojo.stackwalker &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.jdojo.stackwalker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面包含一个LegacyStackWalk类的代码。 该类的输出在JDK 8中运行时生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LegacyStackWalk.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.stackwalker;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LegacyStackWalk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Call m3() directly</span></span><br><span class="line">        System.out.println(<span class="string">"\nWithout using reflection: "</span>);</span><br><span class="line">        m3();</span><br><span class="line">        <span class="comment">// Call m3() using reflection        </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"\nUsing reflection: "</span>);</span><br><span class="line">            LegacyStackWalk<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">                         .getMethod("m3")</span><br><span class="line">                         .invoke(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException |  </span><br><span class="line">                 InvocationTargetException |</span><br><span class="line">                 IllegalAccessException |</span><br><span class="line">                 SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Prints the call stack details</span></span><br><span class="line">        StackTraceElement[] frames = Thread.currentThread()</span><br><span class="line">                                           .getStackTrace();</span><br><span class="line">        <span class="keyword">for</span>(StackTraceElement frame : frames) &#123;</span><br><span class="line">            System.out.println(frame.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.getStackTrace(Thread.java:1552)</span><br><span class="line">com.jdojo.stackwalker.LegacyStackWalk.m3(LegacyStackWalk.java:37)</span><br><span class="line">com.jdojo.stackwalker.LegacyStackWalk.m2(LegacyStackWalk.java:18)</span><br><span class="line">com.jdojo.stackwalker.LegacyStackWalk.m1(LegacyStackWalk.java:12)</span><br><span class="line">com.jdojo.stackwalker.LegacyStackWalk.main(LegacyStackWalk.java:8)</span><br><span class="line">Using reflection:</span><br><span class="line">java.lang.Thread.getStackTrace(Thread.java:1552)</span><br><span class="line">com.jdojo.stackwalker.LegacyStackWalk.m3(LegacyStackWalk.java:37)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">com.jdojo.stackwalker.LegacyStackWalk.m2(LegacyStackWalk.java:25)</span><br><span class="line">com.jdojo.stackwalker.LegacyStackWalk.m1(LegacyStackWalk.java:12)</span><br><span class="line">com.jdojo.stackwalker.LegacyStackWalk.main(LegacyStackWalk.java:8)</span><br></pre></td></tr></table></figure>
<p><code>LegacyStackWalk</code>类的<code>main()</code>方法调用<code>m1()</code>方法，它调用<code>m2()</code>方法。<code>m2()</code>方法直接调用<code>m3()</code>方法两次，其中一次使用了反射。 <code>m3()</code>方法使用Thread类的<code>getStrackTrace()</code>方法获取当前线程栈快照，并使用<code>StackTraceElement</code>类的toString()方法打印栈帧的详细信息。 可以使用此类的方法来获取每个栈帧的相同信息。 当在JDK 9中运行LegacyStackWalk类时，输出包括每行开始处的模块名称和模块版本。 JDK 9的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Without using reflection:</span><br><span class="line">java.base/java.lang.Thread.getStackTrace(Thread.java:1654)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.LegacyStackWalk.m3(LegacyStackWalk.java:37)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.LegacyStackWalk.m2(LegacyStackWalk.java:18)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.LegacyStackWalk.m1(LegacyStackWalk.java:12)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.LegacyStackWalk.main(LegacyStackWalk.java:8)</span><br><span class="line">Using reflection:</span><br><span class="line">java.base/java.lang.Thread.getStackTrace(Thread.java:1654)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.LegacyStackWalk.m3(LegacyStackWalk.java:37)</span><br><span class="line">java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">java.base/java.lang.reflect.Method.invoke(Method.java:538)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.LegacyStackWalk.m2(LegacyStackWalk.java:25)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.LegacyStackWalk.m1(LegacyStackWalk.java:12)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.LegacyStackWalk.main(LegacyStackWalk.java:8)</span><br></pre></td></tr></table></figure>
<h2 id="四-JDK-8-的栈遍历的缺点"><a href="#四-JDK-8-的栈遍历的缺点" class="headerlink" title="四. JDK 8 的栈遍历的缺点"></a>四. JDK 8 的栈遍历的缺点</h2><p>在JDK 9之前，Stack-Walking API存在以下缺点：</p>
<ul>
<li>效率不高。Throwable类的getStrackTrace()方法返回整个栈的快照。 没有办法在栈中只得到几个顶部栈帧。</li>
<li>栈帧包含方法名称和类名称，而不是类引用。 类引用是Class&lt;?&gt;类的实例，而类名只是字符串。</li>
<li>JVM规范允许虚拟机实现在栈中省略一些栈帧来提升性能。 因此，如果有兴趣检查整个栈，那么如果虚拟机隐藏了一些栈帧，则无法执行此操作。</li>
<li>JDK和其他类库中的许多API都是调用者敏感（caller-sensitive）的。 他们的行为基于调用者的类而有所不同。 例如，如果要调用Module类的addExports()方法，调用者的类必须在同一个模块中。 否则，将抛出一个IllegalCallerException异常。 在现有的API中，没有简单而有效的方式来获取调用者的类引用。 这样的API依赖于使用JDK内部API —— sun.reflect.Reflection类的getCallerClass()静态方法。</li>
<li>没有简单的方法来过滤特定实现类的栈帧。</li>
</ul>
<h2 id="五-JDK-9-中的栈遍历"><a href="#五-JDK-9-中的栈遍历" class="headerlink" title="五. JDK 9 中的栈遍历"></a>五. JDK 9 中的栈遍历</h2><p>JDK 9引入了一个新的Stack-Walking API，它由java.lang包中的<code>StackWalker</code>类组成。 该类提供简单而有效的栈遍历。 它为当前线程提供了一个顺序的栈帧流。 从栈生成的最上面的到最下面的栈帧，栈帧按顺序记录。 StackWalker类非常高效，因为它可以懒加载的方式地评估栈帧。 它还包含一个便捷的方法来获取调用者类的引用。 <code>StackWalker</code>类由以下成员组成：</p>
<ul>
<li>StackWalker.Option嵌套枚举</li>
<li>StackWalker.StackFrame嵌套接口</li>
<li>获取StackWalker类实例的方法</li>
<li>处理栈帧的方法</li>
<li>获取调用者类的方法</li>
</ul>
<h3 id="1-指定遍历选项"><a href="#1-指定遍历选项" class="headerlink" title="1. 指定遍历选项"></a>1. 指定遍历选项</h3><p>可以指定零个或多个选项来配置StackWalker。 选项是StackWalker.Option枚举的常量。 常量如下：</p>
<ul>
<li>RETAIN_CLASS_REFERENCE</li>
<li>SHOW_HIDDEN_FRAMES</li>
<li>SHOW_REFLECT_FRAMES</li>
</ul>
<p>如果指定了<code>RETAIN_CLASS_REFERENCE</code>选项，则 <code>StackWalker</code>返回的栈帧将包含声明由该栈帧表示的方法的类的Class对象的引用。 如果要获取Class对象的方法调用者的引用，也需要指定此选项。 默认情况下，此选项不存在。</p>
<p>默认情况下，实现特定的和反射栈帧不包括在StackWalker类返回的栈帧中。 使用SHOW_HIDDEN_FRAMES选项来包括所有隐藏的栈帧。</p>
<p>如果指定了<code>SHOW_REFLECT_FRAMES</code>选项，则<code>StackWalker</code>类返回的栈帧流并包含反射栈帧。 使用此选项可能仍然隐藏实现特定的栈帧，可以使用<code>SHOW_HIDDEN_FRAMES</code>选项显示。</p>
<h3 id="2-表示一个栈帧"><a href="#2-表示一个栈帧" class="headerlink" title="2. 表示一个栈帧"></a>2. 表示一个栈帧</h3><p>在JDK 9之前，StackTraceElement类的实例被用来表示栈帧。 JDK 9中的Stack-Walker API使用<code>StackWalker.StackFrame</code>接口的实例来表示栈帧。</p>
<blockquote>
<p>Tips</p>
<p>StackWalker.StackFrame接口没有具体的实现类，可以直接使用。 JDK中的Stack-Walking API在检索栈帧时为你提供了接口的实例。</p>
</blockquote>
<p><code>StackWalker.StackFrame</code>接口包含以下方法，其中大部分与StackTraceElement类中的方法相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByteCodeIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">getDeclaringClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getFileName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">getMethodName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNativeMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">StackTraceElement <span class="title">toStackTraceElement</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在类文件中，使用为method_info的结构描述每个方法。 method_info结构包含一个保存名为Code的可变长度属性的属性表。 Code属性包含一个code的数组，它保存该方法的字节码指令。 getByteCodeIndex()方法返回到包含由此栈帧表示的执行点的方法的Code属性中的代码数组的索引。 它为本地方法返回-1。 有关代码数组和代码属性的更多信息，请参阅“Java虚拟规范”第4.7.3节，网址为 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/。" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/。</a></p>
<p>如何使用方法的代码数组？ 作为应用程序开发人员，不会在方法中使用字节码索引作为执行点。 JDK确实支持使用内部API读取类文件及其所有属性。 可以使用位于<code>JDK_HOME\bin</code>目录中的javap工具查看方法中每条指令的字节码索引。 需要使用-c选项与javap打印方法的代码数组。 以下命令显示LegacyStackWalk类中所有方法的代码数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Java9Revealed&gt;javap -c com.jdojo.stackwalker\build\classes\com\jdojo\stackwalker\LegacyStackWalk.class</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;LegacyStackWalk.java&quot;</span><br><span class="line">public class com.jdojo.stackwalker.LegacyStackWalk &#123;</span><br><span class="line">  public com.jdojo.stackwalker.LegacyStackWalk();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #2                  // Method m1:()V</span><br><span class="line">       3: return</span><br><span class="line">  public static void m1();</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #3                  // Method m2:()V</span><br><span class="line">       3: return</span><br><span class="line">  public static void m2();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #5                  // String \nWithout using reflection:</span><br><span class="line">       5: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: invokestatic  #7                  // Method m3:()V</span><br><span class="line">...</span><br><span class="line">      32: anewarray     #13                 // class java/lang/Object</span><br><span class="line">      35: invokevirtual #14                 // Method java/lang/reflect/Method.invoke:(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">...</span><br><span class="line">  public static void m3();</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #20                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">       3: invokevirtual #21                 // Method java/lang/Thread.getStackTrace:()[Ljava/lang/StackTraceElement;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在方法m3()中获取调用栈的快照时，m2()方法调用m3()两次。 对于第一次调用，字节码索引为8，第二次为35。</p>
<p><code>getDeclaringClass()</code>方法返回声明由栈帧表示的方法的类的Class对象的引用。 如果该StackWalker没有配置RETAIN_CLASS_REFERENCE选项，它会抛出UnsupportedOperationException异常。</p>
<p><code>toStackTraceElement()</code>方法返回表示相堆栈帧的StackTraceElement类的实例。 如果要使用JDK 9 API来获取StackWalker.StackFrame，但是继续使用使用StackTraceElement类的旧代码来分析栈帧，这种方法非常方便。</p>
<h3 id="3-获取StackWalker"><a href="#3-获取StackWalker" class="headerlink" title="3. 获取StackWalker"></a>3. 获取StackWalker</h3><p>StackWalker类包含返回StackWalker实例的静态工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StackWalker <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">StackWalker <span class="title">getInstance</span> <span class="params">(StackWalker.Option option)</span></span></span><br><span class="line"><span class="function">StackWalker <span class="title">getInstance</span> <span class="params">(Set&lt;StackWalker.Option&gt; options)</span></span></span><br><span class="line"><span class="function">StackWalker <span class="title">getInstance</span> <span class="params">(Set&lt;StackWalker.Option&gt; options, <span class="keyword">int</span> estimateDepth)</span></span></span><br></pre></td></tr></table></figure>
<p>可以使用不同版本的getInstance()方法来配置StackWalker。 默认配置是排除所有隐藏的栈帧，不保留类引用。 允许指定StackWalker.Option的版本使用这些选项进行配置。</p>
<p>estimateDepth参数是一个提示，指示StackWalker预计将遍历的栈帧的评估数，因此可能会优化内部缓冲区的大小。</p>
<p>以下代码片段创建了具有不同配置的StackWalker类的四个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.StackWalker.Option.*;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Get a StackWalker with a default configuration</span></span><br><span class="line">StackWalker sw1 = StackWalker.getInstance();</span><br><span class="line"><span class="comment">// Get a StackWalker that shows reflection frames</span></span><br><span class="line">StackWalker sw2 = StackWalker.getInstance(SHOW_REFLECT_FRAMES);</span><br><span class="line"><span class="comment">// Get a StackWalker that shows all hidden frames</span></span><br><span class="line">StackWalker sw3 = StackWalker.getInstance(SHOW_HIDDEN_FRAMES);</span><br><span class="line"><span class="comment">// Get a StackWalker that shows reflection frames and retains class references</span></span><br><span class="line">StackWalker sw4 = StackWalker.getInstance(Set.of(SHOW_REFLECT_FRAMES, RETAIN_CLASS_REFERENCE));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips</p>
<p>StackWalker是线程安全且可重用的。 多个线程可以使用相同的实例遍历自己的栈。</p>
</blockquote>
<h3 id="4-遍历栈"><a href="#4-遍历栈" class="headerlink" title="4. 遍历栈"></a>4. 遍历栈</h3><p>现在是遍历线程的栈帧的时候了。StackWalker类包含两个方法，可以遍历当前线程的栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> StackWalker.StackFrame&gt; action)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">walk</span><span class="params">(Function&lt;? <span class="keyword">super</span> Stream&lt;StackWalker.StackFrame&gt;,? extends T&gt; function)</span></span></span><br></pre></td></tr></table></figure>
<p>如果需要遍历整个栈，使用forEach()方法。 指定的Consumer将从栈中提供一个栈帧，从最上面的栈帧开始。 以下代码段打印了StackWalker返回的每个栈帧的详细信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prints the details of all stack frames of the current thread</span></span><br><span class="line">StackWalker.getInstance()</span><br><span class="line">           .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>如果要定制栈遍历，例如使用过滤器和映射，使用<code>walk()</code>方法。 <code>walk()</code>方法接受一个Function，它接受一个<code>Stream &lt;StackWalker.StackFrame&gt;</code>作为参数，并可以返回任何类型的对象。 StackWalker将创建栈帧流并将其传递给function。 当功能完成时，StackWalker将关闭流。 传递给walk()方法的流只能遍历一次。 第二次尝试遍历流时会抛出IllegalStateException异常。</p>
<p>以下代码片段使用walk()方法遍历整个栈，打印每个栈帧的详细信息。 这段代码与前面的代码片段使用forEach()方法相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prints the details of all stack frames of the current thread</span></span><br><span class="line">StackWalker.getInstance()</span><br><span class="line">           .walk(s -&gt; &#123;</span><br><span class="line">               s.forEach(System.out::println);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips</p>
<p><code>StackWalker的forEach()</code>方法用于一次处理一个栈帧，而walk()方法用于处理将整个栈为帧流。 可以使用walk()方法来模拟forEach()方法的功能，但反之亦然。</p>
</blockquote>
<p>可能会想知道为什么walk()方法不返回栈帧流而是将流传递给函数。 没有从方法返回堆栈帧流是有意为之的。 流的元素被懒加载的方式评估。 一旦创建了栈帧流，JVM就可以自由地重新组织栈，并且没有确定的方法来检测栈已经改变，仍然保留对其流的引用。 这就是创建和关闭栈帧流由StackWalker类控制的原因。</p>
<p>由于Streams API是广泛的，所以使用walk()方法。 以下代码片段获取列表中当前线程的栈帧的快照。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.StackWalker.StackFrame;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line">...</span><br><span class="line">List&lt;StackFrame&gt; frames = StackWalker.getInstance()</span><br><span class="line">                            .walk(s -&gt; s.collect(toList()));</span><br></pre></td></tr></table></figure>
<p>以下代码段收集列表中当前线程的所有栈帧的字符串形式，不包括表示以m2开头的方法的栈帧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line">...</span><br><span class="line">List&lt;String&gt; list = StackWalker.getInstance()</span><br><span class="line">  .walk(s -&gt; s.filter(f -&gt; !f.getMethodName().startsWith(<span class="string">"m2"</span>))</span><br><span class="line">              .map(f -&gt; f.toString())</span><br><span class="line">              .collect(toList())</span><br><span class="line">       );</span><br></pre></td></tr></table></figure>
<p>以下代码片段收集列表中当前线程的所有栈帧的字符串形式，不包括声明类名称以Test结尾的方法的框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line">...</span><br><span class="line">List&lt;String&gt; list = StackWalker</span><br><span class="line">    .getInstance(RETAIN_CLASS_REFERENCE)</span><br><span class="line">    .walk(s -&gt; s.filter(f -&gt; !f.getDeclaringClass()</span><br><span class="line">                               .getName().endsWith(<span class="string">"Test"</span>))</span><br><span class="line">                .map(f -&gt; f.toString())</span><br><span class="line">                .collect(toList())</span><br><span class="line">          );</span><br></pre></td></tr></table></figure>
<p>以下代码段以字符串的形式收集整个栈信息，将每个栈帧与平台特定的行分隔符分隔开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.joining;</span><br><span class="line">...</span><br><span class="line">String stackStr = StackWalker.getInstance()</span><br><span class="line">$.walk(s -&gt; s.map(f -&gt; f.toString())</span><br><span class="line">             .collect(joining(System.getProperty(<span class="string">"line.separator"</span>)</span><br><span class="line">       )));</span><br></pre></td></tr></table></figure>
<p>下面包含一个完整的程序，用于展示StackWalker类及其walk()方法的使用。 它的main()方法调用m1()方法两次，每次通过StackWalker的一组不同的选项。 m2()方法使用反射来调用m3()方法，它打印堆栈帧细节信息。 第一次，反射栈帧是隐藏的，类引用不可用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StackWalking.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.stackwalker;</span><br><span class="line"><span class="keyword">import</span> java.lang.StackWalker.Option;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.StackWalker.Option.SHOW_REFLECT_FRAMES;</span><br><span class="line"><span class="keyword">import</span> java.lang.StackWalker.StackFrame;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackWalking</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1(Set.of());</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// Retain class references and show reflection frames</span></span><br><span class="line">        m1(Set.of(RETAIN_CLASS_REFERENCE, SHOW_REFLECT_FRAMES));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(Set&lt;Option&gt; options)</span> </span>&#123;</span><br><span class="line">        m2(options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(Set&lt;Option&gt; options)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Call m3() using reflection</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Using StackWalker Options: "</span> + options);</span><br><span class="line">            StackWalking<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">                     .getMethod("m3", Set.class)</span><br><span class="line">                     .invoke(<span class="keyword">null</span>, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException</span><br><span class="line">                | InvocationTargetException</span><br><span class="line">                | IllegalAccessException</span><br><span class="line">                | SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">(Set&lt;Option&gt; options)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Prints the call stack details</span></span><br><span class="line">        StackWalker.getInstance(options)</span><br><span class="line">                   .walk(StackWalking::processStack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Void <span class="title">processStack</span><span class="params">(Stream&lt;StackFrame&gt; stack)</span> </span>&#123;</span><br><span class="line">        stack.forEach(frame -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> bci = frame.getByteCodeIndex();</span><br><span class="line">            String className = frame.getClassName();        </span><br><span class="line">            Class&lt;?&gt; classRef = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                classRef = frame.getDeclaringClass();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">                <span class="comment">// No action to take</span></span><br><span class="line">            &#125;</span><br><span class="line">            String fileName = frame.getFileName();</span><br><span class="line">            <span class="keyword">int</span> lineNumber = frame.getLineNumber();</span><br><span class="line">            String methodName = frame.getMethodName();</span><br><span class="line">            <span class="keyword">boolean</span> isNative = frame.isNativeMethod();</span><br><span class="line">            StackTraceElement sfe = frame.toStackTraceElement();</span><br><span class="line">            System.out.printf(<span class="string">"Native Method=%b"</span>, isNative);</span><br><span class="line">            System.out.printf(<span class="string">", Byte Code Index=%d"</span>, bci);</span><br><span class="line">            System.out.printf(<span class="string">", Module Name=%s"</span>, sfe.getModuleName());</span><br><span class="line">            System.out.printf(<span class="string">", Module Version=%s"</span>, sfe.getModuleVersion());</span><br><span class="line">            System.out.printf(<span class="string">", Class Name=%s"</span>, className);</span><br><span class="line">            System.out.printf(<span class="string">", Class Reference=%s"</span>, classRef);</span><br><span class="line">            System.out.printf(<span class="string">", File Name=%s"</span>, fileName);</span><br><span class="line">            System.out.printf(<span class="string">", Line Number=%d"</span>, lineNumber);</span><br><span class="line">            System.out.printf(<span class="string">", Method Name=%s.%n"</span>, methodName);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Using StackWalker Options: []</span><br><span class="line">Native Method=false, Byte Code Index=9, Module Name=null, Module Version=null, Class Name=com.jdojo.stackwalker.StackWalking, Class Reference=null, FileName=StackWalking.java, Line Number=44, Method Name=m3.</span><br><span class="line">Native Method=false, Byte Code Index=37, Module Name=null, Module Version=null, Class Name=com.jdojo.stackwalker.StackWalking, Class Reference=null, File Name=StackWalking.java, Line Number=32, Method Name=m2.</span><br><span class="line">Native Method=false, Byte Code Index=1, Module Name=null, Module Version=null, Class Name=com.jdojo.stackwalker.StackWalking, Class Reference=null, File Name=StackWalking.java, Line Number=23, Method Name=m1.</span><br><span class="line">Native Method=false, Byte Code Index=3, Module Name=null, Module Version=null, Class Name=com.jdojo.stackwalker.StackWalking, Class Reference=null, File Name=StackWalking.java, Line Number=14, Method Name=main .</span><br><span class="line">Using StackWalker Options: [SHOW_REFLECT_FRAMES, RETAIN_CLASS_REFERENCE]</span><br><span class="line">Native Method=false, Byte Code Index=9, Module Name=null, Module Version=null, Class Name=com.jdojo.stackwalker.StackWalking, Class Reference=class com.jdojo.stackwalker.StackWalking, File Name=StackWalking.java, Line Number=44, Method Name=m3.</span><br><span class="line">Native Method=true, Byte Code Index=-1, Module Name=java.base, Module Version=9-ea, Class Name=jdk.internal.reflect.NativeMethodAccessorImpl, Class Reference=class jdk.internal.reflect.NativeMethodAccessorImpl, File Name=NativeMethodAccessorImpl.java, Line Number=-2, Method Name=invoke0.</span><br><span class="line">Native Method=false, Byte Code Index=100, Module Name=java.base, Module Version=9-ea, Class Name=jdk.internal.reflect.NativeMethodAccessorImpl, Class Reference=class jdk.internal.reflect.NativeMethodAccessorImpl, File Name=NativeMethodAccessorImpl.java, Line Number=62, Method Name=invoke.</span><br><span class="line">Native Method=false, Byte Code Index=6, Module Name=java.base, Module Version=9-ea, Class Name=jdk.internal.reflect.DelegatingMethodAccessorImpl, Class Reference=class jdk.internal.reflect.DelegatingMethodAccessorImpl, File Name=DelegatingMethodAccessorImpl.java, Line Number=43, Method Name=invoke.</span><br><span class="line">Native Method=false, Byte Code Index=59, Module Name=java.base, Module Version=9-ea, Class Name=java.lang.reflect.Method, Class Reference=class java.lang.reflect.Method, File Name=Method.java, Line Number=538, Method Name=invoke.</span><br><span class="line">Native Method=false, Byte Code Index=37, Module Name=null, Module Version=null, Class Name=com.jdojo.stackwalker.StackWalking, Class Reference=class com.jdojo.stackwalker.StackWalking, File Name=StackWalking.java, Line Number=32, Method Name=m2.</span><br><span class="line">Native Method=false, Byte Code Index=1, Module Name=null, Module Version=null, Class Name=com.jdojo.stackwalker.StackWalking, Class Reference=class com.jdojo.stackwalker.StackWalking, File Name=StackWalking.java, Line Number=23, Method Name=m1.</span><br><span class="line">Native Method=false, Byte Code Index=21, Module Name=null, Module Version=null, Class Name=com.jdojo.stackwalker.StackWalking, Class Reference=class com.jdojo.stackwalker.StackWalking, File Name=StackWalking.java, Line Number=19, Method Name=main .</span><br></pre></td></tr></table></figure>
<h3 id="5-认识调用者的类"><a href="#5-认识调用者的类" class="headerlink" title="5. 认识调用者的类"></a>5. 认识调用者的类</h3><p>在JDK 9之前，开发人员依靠以下方法来获取调用者的调用：</p>
<p><code>SecurityManager</code>类的<code>getClassContext()</code>方法，由于该方法受到保护，因此需要进行子类化。<br><code>sun.reflect.Reflection</code>类的<code>getCallerClass()</code>方法，它是一个JDK内部类。<br>JDK 9通过在StackWalker类中添加一个<code>getCallerClass()</code>的方法，使得获取调用者类引用变得容易。 方法的返回类型是Class&lt;?&gt;。 如果StackWalker未配置RETAIN_CLASS_REFERENCE选项，则调用此方法将抛出UnsupportedOperationException异常。 如果栈中没有调用者栈帧，则调用此方法会引发IllegalStateException，例如，运行main()方法调用此方法的类。</p>
<p>那么，哪个类是调用类？ 在Java中，方法和构造函数可调用。 以下讨论使用方法，但是它也适用于构造函数。 假设在S的方法中调用getCallerClass()方法，该方法从T的方法调用。另外假设T的方法在名为C的类中。在这种情况下，C类是调用者类。</p>
<blockquote>
<p>Tips</p>
<p><code>StackWalker</code>类的<code>getCallerClass()</code>方法在查找调用者类时会过滤所有隐藏和反射栈帧，而不管用于获取StackWalker实例的选项如何。</p>
</blockquote>
<p>下面包含一个完整的程序来显示如何获取调用者的类。 它的main()方法调用m1()方法，m1调用m2()方法，m2调用m3()方法。 m3()方法获取StackWalker类的实例并获取调用者类。 请注意，m2()方法使用反射来调用m3()方法。 最后，main()方法尝试获取调用者类。 当运行CallerClassTest类时，main()方法由JVM调用，栈上不会有调用者栈帧。 这将抛出一个IllegalStateException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CallerClassTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.stackwalker;</span><br><span class="line"><span class="keyword">import</span> java.lang.StackWalker.Option;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.StackWalker.Option.SHOW_REFLECT_FRAMES;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Will not be able to get caller class because because the RETAIN_CLASS_REFERENCE</span></span><br><span class="line"><span class="comment">           option is not specified.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        m1(Set.of());</span><br><span class="line">        <span class="comment">// Will print the caller class</span></span><br><span class="line">        m1(Set.of(RETAIN_CLASS_REFERENCE, SHOW_REFLECT_FRAMES));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/* The following statement will throw an IllegalStateException if this class is run</span></span><br><span class="line"><span class="comment">               because there will be no caller class; JVM will call this method. However,</span></span><br><span class="line"><span class="comment">               if the main() method is called in code, no exception will be thrown.            </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Class&lt;?&gt; cls = StackWalker.getInstance(RETAIN_CLASS_REFERENCE)</span><br><span class="line">                                      .getCallerClass();</span><br><span class="line">            System.out.println(<span class="string">"In main method, Caller Class: "</span> + cls.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalCallerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"In main method, Exception: "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(Set&lt;Option&gt; options)</span> </span>&#123;</span><br><span class="line">        m2(options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">(Set&lt;Option&gt; options)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Call m3() using reflection</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CallerClassTest<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">                           .getMethod("m3", Set.class)</span><br><span class="line">                           .invoke(<span class="keyword">null</span>, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | InvocationTargetException</span><br><span class="line">                | IllegalAccessException | SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">(Set&lt;Option&gt; options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Print the caller class</span></span><br><span class="line">            Class&lt;?&gt; cls = StackWalker.getInstance(options)                  </span><br><span class="line">                                      .getCallerClass();</span><br><span class="line">            System.out.println(<span class="string">"Caller Class: "</span> + cls.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Inside m3(): "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside m3(): This stack walker does not have RETAIN_CLASS_REFERENCE access</span><br><span class="line">Caller Class: com.jdojo.stackwalker.CallerClassTest</span><br><span class="line">In main method, Exception: no caller frame</span><br></pre></td></tr></table></figure>
<p>在前面的例子中，收集栈帧的方法是从同一个类的另一个方法中调用的。 我们从另一个类的方法中调用这个方法来看到一个不同的结果。 下面显示了CallerClassTest2的类的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CallerClassTest2.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.stackwalker;</span><br><span class="line"><span class="keyword">import</span> java.lang.StackWalker.Option;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerClassTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;Option&gt; options = Set.of(RETAIN_CLASS_REFERENCE);</span><br><span class="line">        CallerClassTest.m1(options);</span><br><span class="line">        CallerClassTest.m2(options);</span><br><span class="line">        CallerClassTest.m3(options);</span><br><span class="line">        System.out.println(<span class="string">"\nCalling the main() method:"</span>);</span><br><span class="line">        CallerClassTest.main(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"\nUsing an anonymous class:"</span>);</span><br><span class="line">        <span class="keyword">new</span> Object() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                CallerClassTest.m3(options);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">"\nUsing a lambda expression:"</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; CallerClassTest.m3(options))</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Caller Class: com.jdojo.stackwalker.CallerClassTest</span><br><span class="line">Caller Class: com.jdojo.stackwalker.CallerClassTest</span><br><span class="line">Caller Class: com.jdojo.stackwalker.CallerClassTest2</span><br><span class="line"><span class="function">Calling the <span class="title">main</span><span class="params">()</span> method:</span></span><br><span class="line"><span class="function">Inside <span class="title">m3</span><span class="params">()</span>: This stack walker does not have RETAIN_CLASS_REFERENCE access</span></span><br><span class="line"><span class="function">Caller Class: com.jdojo.stackwalker.CallerClassTest</span></span><br><span class="line"><span class="function">In main method, Caller Class: com.jdojo.stackwalker.CallerClassTest2</span></span><br><span class="line"><span class="function">Using an anonymous class:</span></span><br><span class="line"><span class="function">Caller Class: com.jdojo.stackwalker.CallerClassTest2$1</span></span><br><span class="line"><span class="function">Using a lambda expression:</span></span><br><span class="line"><span class="function">Caller Class: com.jdojo.stackwalker.CallerClassTest2</span></span><br></pre></td></tr></table></figure>
<p><code>CallerClassTest2</code>类的<code>main()</code>方法调用CallerClassTest类的四个方法。 当CallerClassTest.m3()从CallerClassTest2类直接调用时，调用者类是CallerClassTest2。 当从CallerClassTest2类调用CallerClassTest.main()方法时，有一个调用者栈帧，调用者类是CallerClassTest2类。 当运行CallerClassTest类时，将其与上一个示例的输出进行比较。 那时，CallerClassTest.main()方法是从JVM调用的，不能在CallerClassTest.main()方法中获得一个调用者类，因为没有调用者栈帧。 最后，CallerClassTest.m3()方法从匿名类和lambda表达式调用。 匿名类被报告为调用者类。 在lambda表达式的情况下，它的闭合类被报告为调用者类。</p>
<h3 id="6-栈遍历权限"><a href="#6-栈遍历权限" class="headerlink" title="6. 栈遍历权限"></a>6. 栈遍历权限</h3><p>当存在Java安全管理器并且使用RETAIN_CLASS_REFERENCE选项配置StackWalker时，将执行权限检查，以确保代码库被授予retainClassReference的java.lang.StackFramePermission值。 如果未授予权限，则抛出SecurityException异常。 在创建StackWalker实例时执行权限检查，而不是在执行栈遍历时。</p>
<p>下包含StackWalkerPermissionCheck类的代码。 它的printStackFrames()方法使用RETAIN_CLASS_REFERENCE选项创建StackWalker实例。 假设没有安全管理器，main()方法调用此方法，它打印堆栈跟踪没有任何问题。 安装安全管理器以后，再次调用printStackFrames()方法。 这一次，抛出一个SecurityException异常，这在输出中显示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StackWalkerPermissionCheck.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.stackwalker;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.StackWalker.Option.RETAIN_CLASS_REFERENCE;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackWalkerPermissionCheck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before installing security manager:"</span>);</span><br><span class="line">        printStackFrames();</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm = <span class="keyword">new</span> SecurityManager();</span><br><span class="line">            System.setSecurityManager(sm);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(</span><br><span class="line">            <span class="string">"\nAfter installing security manager:"</span>);</span><br><span class="line">        printStackFrames();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStackFrames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StackWalker.getInstance(RETAIN_CLASS_REFERENCE)</span><br><span class="line">                       .forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SecurityException  e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not create a "</span> +</span><br><span class="line">                <span class="string">"StackWalker. Error: "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Before installing security manager:</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.StackWalkerPermissionCheck.printStackFrames(StackWalkerPermissionCheck.java:24)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.StackWalkerPermissionCheck.main(StackWalkerPermissionCheck.java:9)</span><br><span class="line">After installing security manager:</span><br><span class="line">Could not create a StackWalker. Error: access denied (&quot;java.lang.StackFramePermission&quot; &quot;retainClassReference&quot;)</span><br></pre></td></tr></table></figure>
<p>下面显示了如何使用RETAIN_CLASS_REFERENCE选项授予创建StackWalker所需的权限。 授予所有代码库的权限，需要将此权限块添加到位于机器上的JAVA_HOME\conf\security目录中的java.policy文件的末尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.lang.StackFramePermission &quot;retainClassReference&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当授予权限以后再运行上面的类时，应该会收到以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Before installing security manager:</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.StackWalkerPermissionCheck.printStackFrames(StackWalkerPermissionCheck.java:24)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.StackWalkerPermissionCheck.main(StackWalkerPermissionCheck.java:9)</span><br><span class="line">After installing security manager:</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.StackWalkerPermissionCheck.printStackFrames(StackWalkerPermissionCheck.java:24)</span><br><span class="line">com.jdojo.stackwalker/com.jdojo.stackwalker.StackWalkerPermissionCheck.main(StackWalkerPermissionCheck.java:18)</span><br></pre></td></tr></table></figure>
<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>JVM中的每个线程都有一个私有的JVM栈，它在创建线程的同时创建。 栈保存栈帧。 JVM栈上的一个栈帧表示给定线程中的Java方法调用。 每次调用一个方法时，都会创建一个新的栈帧并将其推送到栈的顶部。 当方法调用完成时，框架被销毁（从堆栈中弹出）。 在给定的线程中，任何点只有一个栈帧是活动的。 活动栈帧被称为当前栈帧，其方法称为当前方法。 定义当前方法的类称为当前类。</p>
<p>在JDK 9之前，可以使用以下类遍历线程栈中的所有栈帧：Throwable，hread和StackTraceElement。 StackTraceElement类的实例表示栈帧。 Throwable类的getStrackTrace()方法返回包含当前线程栈帧的StackTraceElement []。 Thread类的getStrackTrace()方法返回包含线程栈帧的StackTraceElement []。 数组的第一个元素是栈中的顶层栈帧，表示序列中最后一个方法调用。 一些JVM的实现可能会在返回的数组中省略一些栈帧。</p>
<p>JDK 9使栈遍历变得容易。 它在java.lang包中引入了一个StackWalker的新类。 可以使用getInstance()的静态工厂方法获取StackWalker的实例。 可以使用StackWalker.Option的枚举中定义的常量来表示的选项来配置StackWalker。 <code>StackWalker.StackFrame</code>的嵌套接口的实例表示栈帧。 StackWalker类与StackWalker.StackFrame实例配合使用。 该接口定义了<code>toStackTraceElement()</code>的方法，可用于从<code>StackWalker.StackFrame</code>获取<code>StackTraceElement</code>类的实例。</p>
<p>可以使用StackWalker实例的<code>forEach()</code>和<code>walk()</code>方法遍历当前线程的栈帧。 StackWalker实例的getCallerClass()方法返回调用者类引用。 如果想要代表栈帧的类的引用和调用者类的引用，则必须使用RETAIN_CLASS_REFERENCE配置StackWalker实例。 默认情况下，所有反射栈帧和实现特定的栈帧都不会被StackWalker记录。 如果希望这些框架包含在栈遍历中，请使用SHOW_REFLECT_FRAMES和SHOW_HIDDEN_FRAMES选项来配置StackWalker。 使用SHOW_HIDDEN_FRAMES选项也包括反栈帧。</p>
<p>当存在Java安全管理器并且使用RETAIN_CLASS_REFERENCE选项配置StackWalker时，将执行权限检查，以确保代码库被授予retainClassReference的java.lang.StackFramePermission值。 如果未授予权限，则抛出SecurityException异常。 在创建StackWalker实例时执行权限检查，而不是执行栈遍历时。</p>
</div><p class="readmore"><a href="http://blog.oneforce.cn/online-markdown/?path=https://raw.githubusercontent.com/oneforce/oneforce.github.io/blog/source/_posts/Java/Java 9 Revealed/Chapter 16 虚拟机栈遍历.md">在微信markdown中展示</a></p><div class="tags"><a href="/tags/Java9/">Java9</a><a href="/tags/JVM/">JVM</a></div><div class="post-nav"><a class="pre" href="/2018/05/02/Java/Java字节码的介绍/">Java字节码的介绍</a><a class="next" href="/2018/04/19/Java/Java 9 Revealed/Chapter 20 JDK 9中API层次的改变/">JDK 9中API层次的改变</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://oneforce.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-9-Revealed/">Java 9 Revealed</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Revealed/">Java Revealed</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot2/">SpringBoot2</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/参考文档/">参考文档</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/征信/">征信</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/私募基金/">私募基金</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/资产管理/">资产管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/金融法规/">金融法规</a><span class="category-list-count">15</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/入门系列/" style="font-size: 15px;">入门系列</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/spring-boot/" style="font-size: 15px;">spring boot</a> <a href="/tags/合规/" style="font-size: 15px;">合规</a> <a href="/tags/征信/" style="font-size: 15px;">征信</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/utf8/" style="font-size: 15px;">utf8</a> <a href="/tags/字符集/" style="font-size: 15px;">字符集</a> <a href="/tags/上海/" style="font-size: 15px;">上海</a> <a href="/tags/汽车/" style="font-size: 15px;">汽车</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/金融/" style="font-size: 15px;">金融</a> <a href="/tags/上海市互联网金融行业协会/" style="font-size: 15px;">上海市互联网金融行业协会</a> <a href="/tags/网络借贷/" style="font-size: 15px;">网络借贷</a> <a href="/tags/P2P/" style="font-size: 15px;">P2P</a> <a href="/tags/金融办/" style="font-size: 15px;">金融办</a> <a href="/tags/2018/" style="font-size: 15px;">2018</a> <a href="/tags/指引/" style="font-size: 15px;">指引</a> <a href="/tags/电子合同存证/" style="font-size: 15px;">电子合同存证</a> <a href="/tags/金融科技/" style="font-size: 15px;">金融科技</a> <a href="/tags/银监会/" style="font-size: 15px;">银监会</a> <a href="/tags/资产管理/" style="font-size: 15px;">资产管理</a> <a href="/tags/现金贷/" style="font-size: 15px;">现金贷</a> <a href="/tags/Java9/" style="font-size: 15px;">Java9</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/stream/" style="font-size: 15px;">stream</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/Spring-Boot-2/" style="font-size: 15px;">Spring Boot 2</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/原则/" style="font-size: 15px;">原则</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/p2p/" style="font-size: 15px;">p2p</a> <a href="/tags/代收/" style="font-size: 15px;">代收</a> <a href="/tags/央行/" style="font-size: 15px;">央行</a> <a href="/tags/证监会/" style="font-size: 15px;">证监会</a> <a href="/tags/私募基金/" style="font-size: 15px;">私募基金</a> <a href="/tags/PE/" style="font-size: 15px;">PE</a> <a href="/tags/委托贷款/" style="font-size: 15px;">委托贷款</a> <a href="/tags/私募/" style="font-size: 15px;">私募</a> <a href="/tags/jshell/" style="font-size: 15px;">jshell</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/http-2/" style="font-size: 15px;">http/2</a> <a href="/tags/fabric/" style="font-size: 15px;">fabric</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/说明文档/" style="font-size: 15px;">说明文档</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/10/05/金融/促进金融科技发展 支持上海建设金融科技中心/">金融/促进金融科技发展 支持上海建设金融科技中心</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/05/技术杂项/字符集和字符编码/">技术杂项/字符集和字符编码</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/13/说明/常用正则/">常用正则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/技术杂项/架构/架构在做什么1/">架构在做什么1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/金融/中国人民银行/中国人民银行关于规范代收业务的通知/">中国人民银行关于规范代收业务的通知 (征求意见稿)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/金融/中国人民银行/中国人民银行关于规范代收业务 的通知（征求意见稿）》主要问题说明/">《中国人民银行关于规范代收业务的通知（征求意见稿）》主要问题说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/找书途径及下载方法/">找书途径及下载方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/金融/促进金融科技发展支持上海建设金融科技中心/">促进金融科技发展 支持上海建设金融科技中心</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/技术杂项/spring/设置context-path不能被服务发现的问题/">设置context-path不能被服务发现的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/21/金融/关于办理非法放贷刑事案件若干问题的意见/">关于办理非法放贷刑事案件若干问题的意见</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//oneforce-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">oneforce blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = '//hm.baidu.com/hm.js?' + '718da94a7cf34af2eac95661ab1fc06f';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script>(function () {
  var bp = document.createElement('script');
  bp.src = '//push.zhanzhang.baidu.com/push.js';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>