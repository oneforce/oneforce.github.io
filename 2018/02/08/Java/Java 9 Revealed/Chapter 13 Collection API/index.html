<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java Revealed Chapter 13 Collection API | oneforce blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/mermaid/6.0.0/mermaid.min.css"><script src="//cdn.bootcss.com/mermaid/6.0.0/mermaid.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-113549521-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java Revealed Chapter 13 Collection API</h1><a id="logo" href="/.">oneforce blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java Revealed Chapter 13 Collection API</h1><div class="post-meta">Feb 8, 2018<span> | </span><span class="category"><a href="/categories/Java-Revealed/">Java Revealed</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/02/08/Java/Java 9 Revealed/Chapter 13 Collection API/" href="/2018/02/08/Java/Java 9 Revealed/Chapter 13 Collection API/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-背景"><span class="toc-text">一. 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-不可变的list"><span class="toc-text">二. 不可变的list</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-不可变的set"><span class="toc-text">三. 不可变的set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-不可变的map"><span class="toc-text">四. 不可变的map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-总结"><span class="toc-text">五. 总结</span></a></li></ol></div></div><div class="post-content"><p><a href="http://www.cnblogs.com/IcanFixIt/p/7217042.html" target="_blank" rel="noopener">原文地址</a></p>
<p>在本章中，主要介绍以下内容：</p>
<ul>
<li>在JDK 9之前如何创建了不可变的<code>list</code>，<code>set</code>和<code>map</code>以及使用它们的问题。</li>
<li>如何使用JDK 9中的<code>List</code>接口的<code>of()</code>静态工厂方法创建不可变的list。</li>
<li>如何使用JDK 9中的<code>Set</code>接口的<code>of()</code>静态工厂方法创建不可变的set。</li>
<li>如何使用JDK 9中的<code>Map</code>接口的<code>of()</code>，<code>ofEntries()</code>和<code>entry()</code>静态工厂方法创建不可变的map。</li>
</ul>
<h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h2><p>Collection API由类和接口组成，提供了一种保存和操作不同类型的对象集合的方法，例如list，set和map。 它在Java SE 1.2版本中添加进来。 Java编程语言不支持Collection Literals，这是一种简单易用的方式来声明和初始化集合。 Collection Literals允许通过在紧凑形式的表达式中指定集合的元素来创建特定类型的集合。 Collection Literals的一个示例是一个列表文字，能够创建一个列表，其中包含100和200的整数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = [<span class="number">100</span>, <span class="number">200</span>];</span><br></pre></td></tr></table></figure>
<p>Collection Literals紧凑，使用简单。 由于在创建时已知元素的数量，因此可以实现高效的内存使用。 它可以设计成不可变的，使其线程安全。</p>
<p>在Java编程语言中包含Collection Literals语法在JDK 9之前被考虑过几次。 Java设计师决定不将Collection Literals添加到Java语言中，至少不在JDK 9中。在这一点上将Collection Literals添加到Java将需要太多的努力来获得太少的收益。 他们决定通过在List，Set和Map接口中添加静态工厂方法来更新Collection API，从而可以轻松有效地创建小型的，不可变的集合来实现相同的目标。</p>
<p>现有的Collection API创建可变集合。 可以通过将可变集合包装在另一个对象中创建一个不可变的（或不可修改的）集合，该对象只是原始可变对象的包装器。 要在JDK 8或更早版本中创建两个整数的无法修改的列表，通常使用以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an empty, mutable list</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// Add two elements to the mutable list</span></span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line">list.add(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// Create an immutable list by wrapping the mutable list</span></span><br><span class="line">List&lt;Integer&gt; list2 = Collections.unmodifiableList(list);</span><br></pre></td></tr></table></figure>
<p>这种做法有严重的缺陷。 不可变的list只是可修改list的包装。 有意的是，将变量名为list。 不能使用list2变量修改列表。但是，仍然可以使用list变量来修改列表，并且在使用list2变量读取list时将会反映出修改。 下面包含一个完整的程序来创建一个不可变的list，并显示如何在以后更改其内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreJDK9UnmodifiableList.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.collection;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreJDK9UnmodifiableList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="number">100</span>);</span><br><span class="line">       list.add(<span class="number">200</span>);</span><br><span class="line">       System.out.println(<span class="string">"list = "</span> + list);</span><br><span class="line">       <span class="comment">// Create an unmodifiable list</span></span><br><span class="line">       List&lt;Integer&gt; list2 = Collections.unmodifiableList(list);</span><br><span class="line">       System.out.println(<span class="string">"list2 = "</span> + list2);</span><br><span class="line">       <span class="comment">// Let us add an element using list</span></span><br><span class="line">       list.add(<span class="number">300</span>);</span><br><span class="line">       <span class="comment">// Print the contents of the list using both</span></span><br><span class="line">       <span class="comment">// variables named list and list2</span></span><br><span class="line">       System.out.println(<span class="string">"list = "</span> + list);</span><br><span class="line">       System.out.println(<span class="string">"list2 = "</span> + list2);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">list2 = [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">list = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line">list2 = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br></pre></td></tr></table></figure>
<p>输出显示，只要保留原始列表的引用，就可以更改其内容，并且不可变的list也不是真正不可变的！ 解决此问题的方法是使用新的不可变list引用来覆盖原始引用变量，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line">list.add(<span class="number">200</span>);</span><br><span class="line"><span class="comment">// Create an unmodifiable list and store it in list</span></span><br><span class="line">list = Collections.unmodifiableList(list);</span><br></pre></td></tr></table></figure>
<p>注意，此示例使用多个语句来创建和填入不可变的list。 如果需要在类中声明和初始化不可变的list作为实例或静态变量，则该方法不起作用，因为它涉及多个语句。 这样一个声明需要简单，紧凑，并且包含在一个声明中。 如果在类中使用以前的代码来实例变量，那么代码将类似于以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">       list.add(<span class="number">100</span>);</span><br><span class="line">       list.add(<span class="number">200</span>);</span><br><span class="line">       list = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有其他方式来声明和初始化一个不可变的list，例如使用数组并将其转换为list。 其中三种方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Using an array and converting it to a list</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list2 = Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;( Arrays.asList(<span class="number">100</span>, <span class="number">200</span>)));</span><br><span class="line">    <span class="comment">// Using an anonymous class</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list3 = Collections.unmodifiableList(<span class="keyword">new</span> ArrayList&lt;&gt;()&#123;&#123;add(<span class="number">100</span>); add(<span class="number">200</span>);&#125;&#125;);</span><br><span class="line">    <span class="comment">// Using a stream</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list4 = Collections.unmodifiableList(Stream.of(<span class="number">100</span>, <span class="number">200</span>).collect(Collectors.toList()));</span><br><span class="line">    <span class="comment">// More code goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例证明可以在一个语句中具有不可变的list。 但是，语法是冗长的。 再是效率低下。 例如，只要在list中保存两个整数，则需要创建具有后备数组对象的多个对象来保存这些值。</p>
<p>JDK 9通过向List，Set和Map接口提供静态工厂方法来解决这些问题。 该方法命名为of()并且被重载。 在JDK 9中，可以声明和初始化两个元素的不可变列表，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an unmodifiable list of two integers</span></span><br><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">100</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<h2 id="二-不可变的list"><a href="#二-不可变的list" class="headerlink" title="二. 不可变的list"></a>二. 不可变的list</h2><p>JDK 9将<code>of()</code>静态工厂方法重载到List接口。 它提供了一种简单而紧凑的方式来创建不可变的list。 以下是of()方法的所有版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title">of</span><span class="params">(E... elements)</span></span></span><br></pre></td></tr></table></figure>
<p><code>of()</code>方法有11个特定版本来创建零到十个元素的list。 另一个版本采用可变参数来允许创建任何数量的元素的不可变的list。 你可能会想知道当使用可变参数的版本可以创建具有任意数量的元素的列表时，为什么有这么多版本的方法。 它们存在为性能原因。 API设计人员希望能够有效地使用少量元素的列表。 使用数组实现可变参数。 存在具有非可变参数的方法，以避免将参数装入数组中，这使得它们更有效率。 这些方法使用List接口的特殊实现类用于较小的list。</p>
<p>of()方法返回的list具有以下特征：</p>
<ul>
<li>结构上是不可变的。 尝试添加，替换或删除元素会抛出<code>UnsupportedOperationException</code>异常。</li>
<li>不允许null元素。 如果列表中的元素为null，则抛出<code>NullPointerException</code>异常。</li>
<li>如果所有元素是可序列化的，那么它们也是可序列化的。</li>
<li>元素的顺序与of()方法中指定的，与of(E… elements)方法的可变参数版本中使用的数组相同。</li>
<li>对返回的列表的实现类没有保证。 也就是说，不要指望返回的对象是ArrayList或任何其他实现List接口的类。 这些方法的实现是内部的，不应该假定他们的类名。 例如，<code>List.of()</code>和<code>List.of(&quot;A&quot;)</code>可能会返回两个不同类的对象。</li>
</ul>
<p><code>Collections</code>类包含一个EMPTY_LIST的静态属性，表示不可变的空list。 它还包含一个<code>emptyList()</code>的静态方法来获取不可变的空list。<code>singletonList(T object)</code>方法返回具有指定元素的不可变单例list。 以下代码片段显示了JDK 9和JDK 9之前创建不可变的空和单例list的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creating an empty, immutable List before JDK 9</span></span><br><span class="line">List&lt;Integer&gt; emptyList1 = Collections.EMPTY_LIST;</span><br><span class="line">List&lt;Integer&gt; emptyList2 = Collections.emptyList();</span><br><span class="line"><span class="comment">// Creating an empty list in JDK 9</span></span><br><span class="line">List&lt;Integer&gt; emptyList = List.of();</span><br><span class="line"><span class="comment">// Creating a singleton, immutable List before JDK 9</span></span><br><span class="line">List&lt;Integer&gt; singletonList1 = Collections.singletonList(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// Creating a singleton, immutable List in JDK 9</span></span><br><span class="line">List&lt;Integer&gt; singletonList = List.of(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>如何使用of()方法从数组中创建一个不可变的list？ 答案取决于你想要从数组的列表。 可能需要一个list，其元素与数组的元素相同，或者可能希望使用数组本身作为列表中唯一元素的list。 使用<code>List.of(array)</code>将调用<code>of(E... elements)</code>方法，返回的列表将其元素与数组中的元素相同。 如您希望数组本身是list中的唯一元素，则需要使用<code>List.&lt;array-type&gt;of(array)</code>方法，这将调用<code>of(E e1)</code>方法，返回的列表将具有一个 元素，它是数组本身。 以下代码使用Integer数组来演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = &#123;<span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// Create a list whose elements are the same as the elements</span></span><br><span class="line"><span class="comment">// in the array</span></span><br><span class="line">List&lt;Integer&gt; list1 = List.of(nums);        </span><br><span class="line">System.out.println(<span class="string">"list1 = "</span> + list1);</span><br><span class="line">System.out.println(<span class="string">"list1.size() = "</span> + list1.size());</span><br><span class="line"><span class="comment">// Create a list whose sole element is the array itself</span></span><br><span class="line">List&lt;Integer[]&gt; list2 = List.&lt;Integer[]&gt;of(nums);        </span><br><span class="line">System.out.println(<span class="string">"list2 = "</span> + list2);</span><br><span class="line">System.out.println(<span class="string">"list2.size() = "</span> + list2.size());</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [100, 200]</span><br><span class="line">list1.size() = 2</span><br><span class="line">list2 = [[Ljava.lang.Integer;@7efef64]</span><br><span class="line">list2.size() = 1</span><br></pre></td></tr></table></figure>
<p>下面包含一个完整的程序，显示如何使用List接口的of()静态工厂方法来创建不可变的list。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create few unmodifiable lists</span></span><br><span class="line">        List&lt;Integer&gt; emptyList = List.of();</span><br><span class="line">        List&lt;Integer&gt; luckyNumber = List.of(<span class="number">19</span>);</span><br><span class="line">        List&lt;String&gt; vowels = List.of(<span class="string">"A"</span>, <span class="string">"E"</span>, <span class="string">"I"</span>, <span class="string">"O"</span>, <span class="string">"U"</span>);</span><br><span class="line">        System.out.println(<span class="string">"emptyList = "</span> + emptyList);</span><br><span class="line">        System.out.println(<span class="string">"singletonList = "</span> + luckyNumber);</span><br><span class="line">        System.out.println(<span class="string">"vowels = "</span> + vowels);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try using a null element</span></span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">null</span>, <span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Nulls not allowed in List.of()."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try adding an element</span></span><br><span class="line">            luckyNumber.add(<span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(UnsupportedOperationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Cannot add an element."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try removing an element</span></span><br><span class="line">            luckyNumber.remove(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(UnsupportedOperationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Cannot remove an element."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emptyList = []</span><br><span class="line">singletonList = [19]</span><br><span class="line">vowels = [A, E, I, O, U]</span><br><span class="line">Nulls not allowed in List.of().</span><br><span class="line">Cannot add an element.</span><br><span class="line">Cannot remove an element .</span><br></pre></td></tr></table></figure>
<h2 id="三-不可变的set"><a href="#三-不可变的set" class="headerlink" title="三. 不可变的set"></a>三. 不可变的set</h2><p>JDK 9在Set接口中添加了<code>of()</code>静态工厂方法的重载。 它提供了一种简单而紧凑的方式来创建不可变的set。 以下是of()方法的所有版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">of</span><span class="params">(E... elements)</span></span></span><br></pre></td></tr></table></figure>
<p><code>of()</code>方法的所有版本为性能都做了调整。 可以使用前11个版本来创建一个不可变的零到十个元素的set。 of方法的前11个版本与可变参数的版本一起存在的原因是为了避免将参数装入数组中，最多可设置10个元素。 可变参数的版本可用于创建一个包含任意数量元素的不可变set。</p>
<p><code>of()</code>方法返回的set具有以下特征：</p>
<ul>
<li>结构上是不可变的。 尝试添加，替换或删除元素会抛出UnsupportedOperationException异常。</li>
<li>不允许null元素。 如果set中的元素为null，则抛出NullPointerException异常。</li>
<li>如果所有元素是可序列化的，那么它们是可序列化的。</li>
<li>不允许重复元素。 指定重复的元素会引发一个IllegalArgumentException。</li>
<li>元素的迭代顺序是未指定的。</li>
<li>对于返回的集合的实现类不能保证。 也就是说，不要指望返回的对象是HashSet或任何其他实现Set接口的类。 这些方法的实现是内部的，不应该假定他们的类名。 例如，<code>Set.of()</code>和<code>Set.of(“A”)</code>可能返回两个不同类的对象。</li>
</ul>
<p>Collections类包含一个EMPTY_SET的静态属性，表示不可变的空set。 它还包含emptySet()的静态方法来获取不可变的空set。 它的singleton(T object)方法返回具有指定元素的不可变单例set。 以下代码片段显示了JDK 9和JDK 9之前创建不可变的空和单例set的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creating an empty, immutable Set before JDK 9</span></span><br><span class="line">Set&lt;Integer&gt; emptySet1 = Collections.EMPTY_SET;</span><br><span class="line">Set&lt;Integer&gt; emptySet2 = Collections.emptySet();</span><br><span class="line"><span class="comment">// Creating an empty Set in JDK 9</span></span><br><span class="line">Set&lt;Integer&gt; emptySet = Set.of();</span><br><span class="line"><span class="comment">// Creating a singleton, immutable Set before JDK 9</span></span><br><span class="line">Set&lt;Integer&gt; singletonSet1 = Collections.singleton(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// Creating a singleton, immutable Set in JDK 9</span></span><br><span class="line">Set&lt;Integer&gt; singletonSet = Set.of(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>以下代码显示了如何从数组中创建一个不可变的set。 可以有一个set的元素与数组的元素相同，或者可以使用集合作为唯一元素的集合。 注意，当使用数组元素作为集合的元素时，该数组不能具有重复的元素。 否则，Set.of()方法将抛出IllegalArgumentException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = &#123;<span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// Create a set whose elements are the same as the</span></span><br><span class="line"><span class="comment">// elements of the array</span></span><br><span class="line">Set&lt;Integer&gt; set1 = Set.of(nums);</span><br><span class="line">System.out.println(<span class="string">"set1 = "</span> + set1);</span><br><span class="line">System.out.println(<span class="string">"set1.size() = "</span> + set1.size());</span><br><span class="line"><span class="comment">// Create a set whose sole element is the array itself</span></span><br><span class="line">Set&lt;Integer[]&gt; set2 = Set.&lt;Integer[]&gt;of(nums);</span><br><span class="line">System.out.println(<span class="string">"set2 = "</span> + set2);</span><br><span class="line">System.out.println(<span class="string">"set2.size() = "</span> + set2.size());</span><br><span class="line"><span class="comment">// Create an array with duplicate elements</span></span><br><span class="line">Integer[] nums2 = &#123;<span class="number">101</span>, <span class="number">201</span>, <span class="number">101</span>&#125;;</span><br><span class="line"><span class="comment">// Try creating a set with the array as its sole element</span></span><br><span class="line">Set&lt;Integer[]&gt; set3 = Set.&lt;Integer[]&gt;of(nums2);</span><br><span class="line">System.out.println(<span class="string">"set3 = "</span> + set3);</span><br><span class="line">System.out.println(<span class="string">"set3.size() = "</span> + set3.size());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Try creating a set whose elements are the elements of</span></span><br><span class="line">    <span class="comment">// the array. It will throw an IllegalArgumentException.</span></span><br><span class="line">    Set&lt;Integer&gt; set4 = Set.of(nums2);</span><br><span class="line">    System.out.println(<span class="string">"set4 = "</span> + set4);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set1 = [100, 200]</span><br><span class="line">set1.size() = 2</span><br><span class="line">set2 = [[Ljava.lang.Integer;@47c62251]</span><br><span class="line">set2.size() = 1</span><br><span class="line">set3 = [[Ljava.lang.Integer;@3e6fa38a]</span><br><span class="line">set3.size() = 1</span><br><span class="line">duplicate element: 101</span><br></pre></td></tr></table></figure>
<p>下面包含一个完整的程序，显示如何使用Set接口的<code>of()</code>静态工厂方法来创建不可变的set。 注意程序中包含元音元素的set的输出。 组合的元素可能不会以创建set时指定的相同顺序输出，因为set不保证其元素的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create few unmodifiable sets</span></span><br><span class="line">        Set&lt;Integer&gt; emptySet = Set.of();</span><br><span class="line">        Set&lt;Integer&gt; luckyNumber = Set.of(<span class="number">19</span>);</span><br><span class="line">        Set&lt;String&gt; vowels = Set.of(<span class="string">"A"</span>, <span class="string">"E"</span>, <span class="string">"I"</span>, <span class="string">"O"</span>, <span class="string">"U"</span>);</span><br><span class="line">        System.out.println(<span class="string">"emptySet = "</span> + emptySet);</span><br><span class="line">        System.out.println(<span class="string">"singletonSet = "</span> + luckyNumber);</span><br><span class="line">        System.out.println(<span class="string">"vowels = "</span> + vowels);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try using a null element</span></span><br><span class="line">            Set&lt;Integer&gt; set = Set.of(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">null</span>, <span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Nulls not allowed in Set.of()."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try using duplicate elements</span></span><br><span class="line">            Set&lt;Integer&gt; set = Set.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try adding an element</span></span><br><span class="line">            luckyNumber.add(<span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(UnsupportedOperationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Cannot add an element."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try removing an element</span></span><br><span class="line">            luckyNumber.remove(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(UnsupportedOperationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Cannot remove an element."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">emptySet = []</span><br><span class="line">singletonSet = [19]</span><br><span class="line">vowels = [E, O, A, U, I]</span><br><span class="line">Nulls not allowed <span class="keyword">in</span> Set.of().</span><br><span class="line">duplicate element: 2</span><br><span class="line">Cannot add an element.</span><br><span class="line">Cannot remove an element.</span><br></pre></td></tr></table></figure>
<h2 id="四-不可变的map"><a href="#四-不可变的map" class="headerlink" title="四. 不可变的map"></a>四. 不可变的map</h2><p>JDK 9将<code>of()</code>静态工厂方法重载添到Map接口中。 它提供了一种简单而紧凑的方式来创建不可变的map。 方法的实现为性能做了调整。 以下是<code>of()</code>方法的11个版本，可以创建一个不可变的零到十个键值条目的map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10)</span></span></span><br></pre></td></tr></table></figure>
<p>注意在<code>of()</code>方法中的参数的位置。 第一个和第二个参数分别是map中第一个键值对的键和值；第三个和第四个参数分别是map中第二个键值对的键和值。 注意，在Map中，没有像在List和Set中可变参数的<code>of()</code>方法。 这是因为Map条目包含两个值（键值和值），并且Java中的方法中只能有一个可变参数。 以下代码片段显示了如何使用<code>of()</code>方法创建map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An empty, unmodifiable Map</span></span><br><span class="line">Map&lt;Integer, String&gt; emptyMap = Map.of();</span><br><span class="line"><span class="comment">// A singleton, unmodifiable Map</span></span><br><span class="line">Map&lt;Integer, String&gt; singletonMap = Map.of(<span class="number">1</span>, <span class="string">"One"</span>);</span><br><span class="line"><span class="comment">// A unmodifiable Map with two entries</span></span><br><span class="line">Map&lt;Integer, String&gt; luckyNumbers = Map.of(<span class="number">1</span>, <span class="string">"One"</span>, <span class="number">2</span>, <span class="string">"Two"</span>);</span><br></pre></td></tr></table></figure>
<p>要创建具有任意数量条目的不可修改的Map，JDK 9在Map接口中提供了一个<code>ofEntries()</code>的静态方法，它的签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">ofEntries</span><span class="params">(Map.Entry&lt;? extends K,? extends V&gt;... entries)</span></span></span><br></pre></td></tr></table></figure>
<p>要使用<code>ofEntries()</code>方法，需要在<code>Map.Entry</code>实例中包含每个map键值对。 JDK 9在Map接口中提供了一个方便的<code>entry()</code>静态方法来创建<code>Map.Entry</code>的实例。 <code>entry()</code>方法的签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;K,V&gt; Map.<span class="function">Entry&lt;K,V&gt; <span class="title">entry</span><span class="params">(K k, V v)</span></span></span><br></pre></td></tr></table></figure>
<p>为了保持表达式的可读性和紧凑性，需要为Map.entry方法使用静态导入，并使用如下所示的语句来创建一个具有任意数量条目的不可修改的map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Map.entry;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Use the Map.ofEntries() and Map.entry() methods to</span></span><br><span class="line"><span class="comment">// create an unmodifiable Map</span></span><br><span class="line">Map&lt;Integer, String&gt; numberToWord =</span><br><span class="line">          Map.ofEntries(entry(<span class="number">1</span>, <span class="string">"One"</span>),</span><br><span class="line">                        entry(<span class="number">2</span>, <span class="string">"Two"</span>),</span><br><span class="line">                        entry(<span class="number">3</span>, <span class="string">"Three"</span>));</span><br></pre></td></tr></table></figure>
<p>Map接口的<code>of()</code>和<code>ofEntries()</code>方法返回的map具有以下特征：</p>
<ul>
<li>在结构上是不可变的。 尝试添加，替换或删除条目会抛出<code>UnsupportedOperationException</code>异常。</li>
<li>不允许在键或值中为null。 如果map中的键或值为null，则抛出<code>NullPointerException</code>异常。</li>
<li>如果所有键和值都是可序列化的，它们是可序列化的。</li>
<li>不允许重复的键。 指定重复的键会引发<code>IllegalArgumentException</code>异常。</li>
<li>映射的迭代顺序是未指定的。</li>
<li>对于返回的Map的实现类不能保证。 也就是说，不要指望返回的对象是HashMap或实现Map接口的任何其他类。 这些方法的实现是内部的，不应该假定他们的类名。 例如，<code>Map.of()</code>和<code>Map.of(1, &quot;One&quot;)</code>可能会返回两个不同类的对象。</li>
</ul>
<p>Collections类包含EMPTY_MAP的静态字段，表示不可变的空map。 它还包含一个emptyMap()的静态方法来获取不可变的空map。 <code>singletonMap(K key, V value)</code>方法返回具有指定键和值的不可变的单例map。 以下代段显示了JDK 9和JDK 9之前创建不可变空map和单例map的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creating an empty, immutable Map before JDK 9</span></span><br><span class="line">Map&lt;Integer,String&gt; emptyMap1 = Collections.EMPTY_MAP;</span><br><span class="line">Map&lt;Integer,String&gt; emptyMap2 = Collections.emptyMap();</span><br><span class="line"><span class="comment">// Creating an empty Map in JDK 9</span></span><br><span class="line">Map&lt;Integer,String&gt; emptyMap = Map.of();</span><br><span class="line"><span class="comment">// Creating a singleton, immutable Map before JDK 9</span></span><br><span class="line">Map&lt;Integer,String&gt; singletonMap1 =</span><br><span class="line">    Collections.singletonMap(<span class="number">1</span>, <span class="string">"One"</span>);</span><br><span class="line"><span class="comment">// Creating a singleton, immutable Map in JDK 9</span></span><br><span class="line">Map&lt;Integer,String&gt; singletonMap = Map.of(<span class="number">1</span>, <span class="string">"One"</span>);</span><br></pre></td></tr></table></figure>
<p>下面包含一个完整的程序，显示如何使用Map接口的of()，ofEntries()和entry() 静态方法来创建不可变的<br>map。 请注意map中指定日期的顺序以及输出中显示的顺序。 它们可能不匹配，因为map更像set，不能保证其条目的检索顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Map.entry;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create few unmodifiable maps</span></span><br><span class="line">        Map&lt;Integer,String&gt; emptyMap = Map.of();</span><br><span class="line">        Map&lt;Integer,String&gt; luckyNumber = Map.of(<span class="number">19</span>, <span class="string">"Nineteen"</span>);</span><br><span class="line">        Map&lt;Integer,String&gt; numberToWord =</span><br><span class="line">                Map.of(<span class="number">1</span>, <span class="string">"One"</span>, <span class="number">2</span>, <span class="string">"Two"</span>, <span class="number">3</span>, <span class="string">"Three"</span>);</span><br><span class="line">        Map&lt;String,String&gt; days = Map.ofEntries(</span><br><span class="line">                entry(<span class="string">"Mon"</span>, <span class="string">"Monday"</span>),</span><br><span class="line">                entry(<span class="string">"Tue"</span>, <span class="string">"Tuesday"</span>),</span><br><span class="line">                entry(<span class="string">"Wed"</span>, <span class="string">"Wednesday"</span>),</span><br><span class="line">                entry(<span class="string">"Thu"</span>, <span class="string">"Thursday"</span>),</span><br><span class="line">                entry(<span class="string">"Fri"</span>, <span class="string">"Friday"</span>),</span><br><span class="line">                entry(<span class="string">"Sat"</span>, <span class="string">"Saturday"</span>),</span><br><span class="line">                entry(<span class="string">"Sun"</span>, <span class="string">"Sunday"</span>));</span><br><span class="line">        System.out.println(<span class="string">"emptyMap = "</span> + emptyMap);</span><br><span class="line">        System.out.println(<span class="string">"singletonMap = "</span> + luckyNumber);</span><br><span class="line">        System.out.println(<span class="string">"numberToWord = "</span> + numberToWord);</span><br><span class="line">        System.out.println(<span class="string">"days = "</span> + days);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try using a null value</span></span><br><span class="line">            Map&lt;Integer,String&gt; map = Map.of(<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Nulls not allowed in Map.of()."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try using duplicate keys</span></span><br><span class="line">            Map&lt;Integer,String&gt; map = Map.of(<span class="number">1</span>, <span class="string">"One"</span>, <span class="number">1</span>, <span class="string">"On"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try adding an entry</span></span><br><span class="line">            luckyNumber.put(<span class="number">8</span>, <span class="string">"Eight"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(UnsupportedOperationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Cannot add an entry."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Try removing an entry</span></span><br><span class="line">            luckyNumber.remove(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(UnsupportedOperationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Cannot remove an entry."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">emptyMap = &#123;&#125;</span><br><span class="line">singletonMap = &#123;19=Nineteen&#125;</span><br><span class="line">numberToWord = &#123;1=One, 3=Three, 2=Two&#125;</span><br><span class="line">days = &#123;Sat=Saturday, Tue=Tuesday, Thu=Thursday, Sun=Sunday, Wed=Wednesday, Fri=Friday, Mon=Monday&#125;</span><br><span class="line">Nulls not allowed in Map.of().</span><br><span class="line">duplicate key: 1</span><br><span class="line">Cannot add an entry.</span><br><span class="line">Cannot remove an entry.</span><br></pre></td></tr></table></figure>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>在Java语言中支持collection literals是非常需要的功能。 JDK 9替代了对collection literals的支持，更新了Collection API，而是在List，Set和Map接口中添加了<code>of()</code>静态工厂方法，分别返回一个不可变的List，Set和Map。该方法被重载，指定集合的零到十个元素。 List和Set接口提供了可变参数的<code>of()</code>方法，用于创建一个包含任意数量的元素的List和Set。 Map接口提供了<code>ofEntries()</code>静态工厂方法，用于创建一个不可变的任意数量条目的Map。 Map接口还包含一个静态的entry()方法，它接受一个键和一个值作为参数并返回一个<code>Map.Entry</code>实例。 <code>ofEntries()</code>和<code>entry()</code>方法一起使用来创建任意数量条目的不可变的Map。</p>
<p>这些接口中的新的静态工厂方法为性能做了调整。 <code>List.of()</code>和<code>Set.of()</code>方法不允许使用null元素。 <code>Set.of()</code>方法不允许重复的元素。 <code>Map.of()</code>和<code>Map.ofEntries()</code>方法不允许重复键，或者将null作为键或值。</p>
</div><p class="readmore"><a href="http://blog.oneforce.cn/online-markdown/?path=https://raw.githubusercontent.com/oneforce/oneforce.github.io/blog/source/_posts/Java/Java 9 Revealed/Chapter 13 Collection API.md">在微信markdown中展示</a></p><div class="tags"><a href="/tags/Java9/">Java9</a><a href="/tags/collection/">collection</a><a href="/tags/lambda/">lambda</a></div><div class="post-nav"><a class="pre" href="/2018/02/08/Java/Java 9 Revealed/Chapter 12 Process API/">Java 9 Revealed Chapter 12 Process API</a><a class="next" href="/2018/02/07/微信跳一跳是否是社交游戏/">微信跳一跳是否是社交游戏</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://oneforce.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-9-Revealed/">Java 9 Revealed</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Revealed/">Java Revealed</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot2/">SpringBoot2</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/参考文档/">参考文档</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/征信/">征信</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/私募基金/">私募基金</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/资产管理/">资产管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/金融法规/">金融法规</a><span class="category-list-count">15</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/入门系列/" style="font-size: 15px;">入门系列</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/spring-boot/" style="font-size: 15px;">spring boot</a> <a href="/tags/合规/" style="font-size: 15px;">合规</a> <a href="/tags/征信/" style="font-size: 15px;">征信</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/utf8/" style="font-size: 15px;">utf8</a> <a href="/tags/字符集/" style="font-size: 15px;">字符集</a> <a href="/tags/上海/" style="font-size: 15px;">上海</a> <a href="/tags/汽车/" style="font-size: 15px;">汽车</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/金融/" style="font-size: 15px;">金融</a> <a href="/tags/上海市互联网金融行业协会/" style="font-size: 15px;">上海市互联网金融行业协会</a> <a href="/tags/网络借贷/" style="font-size: 15px;">网络借贷</a> <a href="/tags/P2P/" style="font-size: 15px;">P2P</a> <a href="/tags/金融办/" style="font-size: 15px;">金融办</a> <a href="/tags/2018/" style="font-size: 15px;">2018</a> <a href="/tags/指引/" style="font-size: 15px;">指引</a> <a href="/tags/电子合同存证/" style="font-size: 15px;">电子合同存证</a> <a href="/tags/金融科技/" style="font-size: 15px;">金融科技</a> <a href="/tags/银监会/" style="font-size: 15px;">银监会</a> <a href="/tags/资产管理/" style="font-size: 15px;">资产管理</a> <a href="/tags/现金贷/" style="font-size: 15px;">现金贷</a> <a href="/tags/Java9/" style="font-size: 15px;">Java9</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/stream/" style="font-size: 15px;">stream</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/Spring-Boot-2/" style="font-size: 15px;">Spring Boot 2</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/原则/" style="font-size: 15px;">原则</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/p2p/" style="font-size: 15px;">p2p</a> <a href="/tags/代收/" style="font-size: 15px;">代收</a> <a href="/tags/央行/" style="font-size: 15px;">央行</a> <a href="/tags/证监会/" style="font-size: 15px;">证监会</a> <a href="/tags/私募基金/" style="font-size: 15px;">私募基金</a> <a href="/tags/PE/" style="font-size: 15px;">PE</a> <a href="/tags/委托贷款/" style="font-size: 15px;">委托贷款</a> <a href="/tags/私募/" style="font-size: 15px;">私募</a> <a href="/tags/jshell/" style="font-size: 15px;">jshell</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/http-2/" style="font-size: 15px;">http/2</a> <a href="/tags/fabric/" style="font-size: 15px;">fabric</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/说明文档/" style="font-size: 15px;">说明文档</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/10/05/金融/促进金融科技发展 支持上海建设金融科技中心/">金融/促进金融科技发展 支持上海建设金融科技中心</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/05/技术杂项/字符集和字符编码/">技术杂项/字符集和字符编码</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/13/说明/常用正则/">常用正则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/技术杂项/架构/架构在做什么1/">架构在做什么1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/金融/中国人民银行/中国人民银行关于规范代收业务的通知/">中国人民银行关于规范代收业务的通知 (征求意见稿)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/金融/中国人民银行/中国人民银行关于规范代收业务 的通知（征求意见稿）》主要问题说明/">《中国人民银行关于规范代收业务的通知（征求意见稿）》主要问题说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/找书途径及下载方法/">找书途径及下载方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/金融/促进金融科技发展支持上海建设金融科技中心/">促进金融科技发展 支持上海建设金融科技中心</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/技术杂项/spring/设置context-path不能被服务发现的问题/">设置context-path不能被服务发现的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/21/金融/关于办理非法放贷刑事案件若干问题的意见/">关于办理非法放贷刑事案件若干问题的意见</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//oneforce-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">oneforce blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = '//hm.baidu.com/hm.js?' + '718da94a7cf34af2eac95661ab1fc06f';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script>(function () {
  var bp = document.createElement('script');
  bp.src = '//push.zhanzhang.baidu.com/push.js';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>