<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>http/2 client API | oneforce blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/mermaid/6.0.0/mermaid.min.css"><script src="//cdn.bootcss.com/mermaid/6.0.0/mermaid.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-113549521-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">http/2 client API</h1><a id="logo" href="/.">oneforce blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">http/2 client API</h1><div class="post-meta">Mar 5, 2018<span> | </span><span class="category"><a href="/categories/Java-9-Revealed/">Java 9 Revealed</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/03/05/Java/Java 9 Revealed/Chapter 14 HTTP2 Client API/" href="/2018/03/05/Java/Java 9 Revealed/Chapter 14 HTTP2 Client API/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-什么是HTTP-2-Client-API？"><span class="toc-text">一. 什么是HTTP/2 Client API？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-设置案例"><span class="toc-text">二. 设置案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-创建HTTP客户端"><span class="toc-text">三. 创建HTTP客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-处理HTTP请求"><span class="toc-text">四. 处理HTTP请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-获取HTTP请求构建器"><span class="toc-text">1. 获取HTTP请求构建器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-设置HTTP请求参数"><span class="toc-text">2. 设置HTTP请求参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-设置请求首部"><span class="toc-text">五. 设置请求首部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-设置请求内容实体"><span class="toc-text">六. 设置请求内容实体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-创建HTTP请求"><span class="toc-text">七. 创建HTTP请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-处理HTTP响应"><span class="toc-text">八. 处理HTTP响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-处理响应状态和首部"><span class="toc-text">1. 处理响应状态和首部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-处理响应内容实体"><span class="toc-text">2. 处理响应内容实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-处理响应的Trailer"><span class="toc-text">3. 处理响应的Trailer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九-设置请求重定向策略"><span class="toc-text">九. 设置请求重定向策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十-使用WebSocket协议"><span class="toc-text">十. 使用WebSocket协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-创建服务器端Endpoint"><span class="toc-text">1. 创建服务器端Endpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-创建客户端Endpoint"><span class="toc-text">2. 创建客户端Endpoint</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一-创建监听器"><span class="toc-text">十一. 创建监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二-构建Endpoint"><span class="toc-text">十二. 构建Endpoint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三-向对等体发送消息"><span class="toc-text">十三. 向对等体发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-运行WebSocket程序"><span class="toc-text">1. 运行WebSocket程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-WebSocket应用程序疑难解答"><span class="toc-text">2. WebSocket应用程序疑难解答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四-总结"><span class="toc-text">十四. 总结</span></a></li></ol></div></div><div class="post-content"><p><a href="http://www.cnblogs.com/IcanFixIt/p/7229611.html" target="_blank" rel="noopener">原文地址</a></p>
<p>在此章中，主要介绍以下内容：</p>
<ul>
<li>什么是HTTP/2 Client API</li>
<li>如何创建HTTP客户端</li>
<li>如何使HTTP请求</li>
<li>如何接收HTTP响应</li>
<li>如何创建WebSocket的endpoints</li>
<li>如何将未经请求的数据从服务器推送到客户端</li>
</ul>
<p>JDK 9将<code>HTTP/2 Client API</code>作为名为<code>jdk.incubator.httpclient</code>的孵化器模块。 该模块导出包含所有公共API的<code>jdk.incubator.http</code>包。 孵化器模块不是Java SE的一部分。 在Java SE 10中，它将被标准化，并成为Java SE 10的一部分，否则将被删除。 请参阅 <a href="http://openjdk.java.net/jeps/11上的网页，以了解有关JDK中孵化器模块的更多信息。" target="_blank" rel="noopener">http://openjdk.java.net/jeps/11上的网页，以了解有关JDK中孵化器模块的更多信息。</a></p>
<p>孵化器模块在编译时或运行时未被默认解析，因此需要使用<code>--add-modules</code>选项将<code>jdk.incubator.httpclient</code>模块添加到默认的根模块中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;javac|java|jmod...&gt; -add-modules jdk.incubator.httpclient ...</span><br></pre></td></tr></table></figure>
<p>如果另一个模块读取并解析了第二个模块，则也相应解析了孵化器模块。 在本章中，将创建一个读取<code>jdk.incubator.httpclient</code>模块的模块，不必使用-add-modules选项来解析。</p>
<p>因为孵化器模块提供的API还不是最终的，当在编译时或运行时使用孵化器模块时，会在标准错误上打印警告。 警告信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Using incubator modules: jdk.incubator.httpclient</span><br></pre></td></tr></table></figure>
<p>孵化器模块的名称和包含孵化器API的软件包以<code>jdk.incubator</code>开始。 一旦它们被标准化并包含在Java SE中，它们的名称将被更改为使用标准的Java命名约定。 例如，模块名称<code>jdk.incubator.httpclient</code>可能会在Java SE 10中成为<code>java.httpclient</code>。</p>
<p>因为<code>jdk.incubator.httpclient</code>模块不在Java SE中，所以将不会为此模块找到Javadoc。 为了生成此模块的Javadoc，并将其包含在本书的源代码中。 可以使用下载的源代码中的Java9Revealed/jdk.incubator.httpclient/dist/javadoc/index.html文件访问Javadoc。 使用JDK 9早期访问构建158的JDK版本来生成Javadoc。 API可能会改变，可能需要重新生成Javadoc。 以下是具体的步骤：</p>
<ul>
<li>源代码包含与项目名称相同目录中的jdk.incubator.httpclient NetBeans项目。</li>
<li>安装JDK 9时，其源代码将作为src.zip文件复制到安装目录中。 将所有内容从src.zip文件中的jdk.incubator.httpclient目录复制到下载的源代码中的Java9revealed\jdk.incubator.httpclient\src目录中。</li>
<li>在NetBeans中打开jdk.incubator.httpclient项目。</li>
<li>右键单击NetBeans中的项目，然后选择“生成Javadoc”选项。 你会收到错误和警告，可以忽略。 它将在<code>Java9Revealed/jdk.incubator.httpclient/dist/javadoc</code>目录中生成Javadoc。 打开此目录中的index.html文件，查看<code>jdk.incubator.httpclient</code>模块的Javadoc。</li>
</ul>
<h2 id="一-什么是HTTP-2-Client-API？"><a href="#一-什么是HTTP-2-Client-API？" class="headerlink" title="一. 什么是HTTP/2 Client API？"></a>一. 什么是HTTP/2 Client API？</h2><p>自JDK 1.0以来，Java已经支持<code>HTTP/1.1</code>。 HTTP API由java.net包中的几种类型组成。 现有的API有以下问题：</p>
<ul>
<li>它被设计为支持多个协议，如http，ftp，gopher等，其中许多协议不再被使用。</li>
<li>太抽象了，很难使用。</li>
<li>它包含许多未公开的行为。</li>
<li>它只支持一种模式，阻塞模式，这要求每个请求/响应有一个单独的线程。</li>
</ul>
<p>2015年5月，IETF（Internet Engineering Task Force）发布了HTTP/2规范。 有关HTTP/2规范的完整文本，请访问<a href="https://tools.ietf.org/html/rfc7540。" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7540。</a> HTTP/2不会修改应用程序级语义。 也就是说，对应用程序中的HTTP协议的了解和使用情况并没有改变。 它具有更有效的方式准备数据包，然后发送到客户端和服务器之间的电线。 所有之前知道的HTTP，如HTTP头，方法，状态码，URL等都保持不变。 HTTP/2尝试解决与HTTP/1连接所面临的许多性能相关的问题：</p>
<ul>
<li>HTTP/2支持二进制数据交换，来代替HTTP/1.1支持的文本数据。</li>
<li>HTTP/2支持多路复用和并发，这意味着多个数据交换可以同时发生在TCP连接的两个方向上，而对请求的响应可以按顺序接收。 这消除了在对等体之间具有多个连接的开销，这在使用HTTP/1.1时通常是这种情况。 在HTTP/1.1中，必须按照发送请求的顺序接收响应，这称为head-of-line阻塞。 HTTP/2通过在同一TCP连接上进行复用来解决线路阻塞问题。</li>
<li>客户端可以建议请求的优先级，服务器可以在对响应进行优先级排序时予以遵守。</li>
<li>HTTP首部（header）被压缩，这大大降低了首部大小，从而降低了延迟。</li>
<li>它允许从服务器到客户端的资源推送。</li>
</ul>
<p>JDK 9不是更新现有的<code>HTTP/1.1 API</code>，而是提供了一个支持<code>HTTP/1.1</code>和<code>HTTP/2</code>的<code>HTTP/2 Client API</code>。 该API旨在最终取代旧的API。 新API还包含使用WebSocket协议开发客户端应用程序的类和接口。 有关完整的WebSocket协议规范，请访问<a href="https://tools.ietf.org/html/rfc6455。" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6455。</a> 新的HTTP/2客户端API与现有的API相比有以下几个好处：</p>
<ul>
<li>在大多数常见情况下，学习和使用简单易用。</li>
<li>它提供基于事件的通知。 例如，当收到首部信息，收到正文并发生错误时，会生成通知。</li>
<li>它支持服务器推送，这允许服务器将资源推送到客户端，而客户端不需要明确的请求。 它使得与服务器的WebSocket通信设置变得简单。</li>
<li>它支持HTTP/2和HTTPS/TLS协议。</li>
<li>它同时工作在同步（阻塞模式）和异步（非阻塞模式）模式。</li>
</ul>
<p>新的API由不到20种类型组成，其中有四种是主要类型。 当使用这四种类型时，会使用其他类型。 新API还使用旧API中的几种类型。 新的API位于jdk.incubator.httpclient模块中的jdk.incubator.http包中。 主要类型有三个抽象类和一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpClient <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">HttpRequest</span> <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">HttpResponse</span> <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">WebSocket</span> <span class="title">interface</span></span></span><br></pre></td></tr></table></figure>
<p><code>HttpClient</code>类的实例是用于保存可用于多个HTTP请求的配置的容器，而不是为每个HTTP请求单独设置它们。 <code>HttpRequest</code>类的实例表示可以发送到服务器的HTTP请求。 <code>HttpResponse</code>类的实例表示HTTP响应。 <code>WebSocket</code>接口的实例表示一个WebSocket客户端。 可以使用Java EE 7 WebSocket API创建WebSocket服务器。</p>
<p>使用构建器创建<code>HttpClient</code>，<code>HttpRequest</code>和<code>WebSocket</code>的实例。 每个类型都包含一个名为<code>Builder</code>的嵌套类/接口，用于构建该类型的实例。 请注意，不用创建HttpResponse，它作为所做的HTTP请求的一部分返回。 新的HTTP/2 Client API非常简单，只需在一个语句中读取HTTP资源！ 以下代码段使用GET请求，以URL <a href="https://www.google.com/作为字符串读取内容：" target="_blank" rel="noopener">https://www.google.com/作为字符串读取内容：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String responseBody = HttpClient.newHttpClient()</span><br><span class="line">         .send(HttpRequest.newBuilder(<span class="keyword">new</span> URI(<span class="string">"https://www.google.com/"</span>))</span><br><span class="line">               .GET()</span><br><span class="line">               .build(), BodyHandler.asString())</span><br><span class="line">         .body();</span><br></pre></td></tr></table></figure>
<p>处理HTTP请求的典型步骤如下：</p>
<ul>
<li>创建HTTP客户端对象以保存HTTP配置信息。</li>
<li>创建HTTP请求对象并使用要发送到服务器的信息进行填充。</li>
<li>将HTTP请求发送到服务器。</li>
<li>接收来自服务器的HTTP响应对象作为响应。</li>
<li>处理HTTP响应。</li>
</ul>
<h2 id="二-设置案例"><a href="#二-设置案例" class="headerlink" title="二. 设置案例"></a>二. 设置案例</h2><p>在本章中使用了许多涉及与Web服务器交互的例子。 不是使用部署在Internet上的Web应用程序，而是在NetBeans中创建了一个可以在本地部署的Web应用程序项目。 如果更喜欢使用其他Web应用程序，则需要更改示例中使用的URL。</p>
<p>NetBeans Web应用程序位于源代码的webapp目录中。 通过在GlassFish服务器4.1.1和Tomcat 8/9上部署Web应用程序来测试示例。 可以从<a href="https://netbeans.org/下载带有GlassFish服务器的NetBeans" target="_blank" rel="noopener">https://netbeans.org/下载带有GlassFish服务器的NetBeans</a> IDE。 在8080端口的GlassFish服务器上运行HTTP监听器。如果在另一个端口上运行HTTP监听器，则需要更改示例URL中的端口号。</p>
<p>本章的所有HTTP客户端程序都位于<code>com.jdojo.http.client</code>模块中，其声明如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-info.java</span></span><br><span class="line"><span class="keyword">module</span> com.jdojo.http.client &#123;</span><br><span class="line">    <span class="keyword">requires</span> jdk.incubator.httpclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-创建HTTP客户端"><a href="#三-创建HTTP客户端" class="headerlink" title="三. 创建HTTP客户端"></a>三. 创建HTTP客户端</h2><p>HTTP请求需要将配置信息发送到服务器，以便服务器知道要使用的身份验证器，SSL配置详细信息，要使用的cookie管理器，代理信息，服务器重定向请求时的重定向策略等。 HttpClient类的实例保存这些特定于请求的配置，它们可以重用于多个请求。 可以根据每个请求覆盖其中的一些配置。 发送HTTP请求时，需要指定将提供请求的配置信息的HttpClient对象。 HttpClient包含用于所有HTTP请求的以下信息：验证器，cookie管理器，执行器，重定向策略，请求优先级，代理选择器，SSL上下文，SSL参数和HTTP版本。</p>
<ul>
<li><strong>认证者</strong>是<code>java.net.Authenticator</code>类的实例。 它用于HTTP身份验证。 默认是不使用验证器。</li>
<li><strong>Cookie管理器</strong>用于管理<code>HTTP Cookie</code>。 它是<code>java.net.CookieManager</code>类的一个实例。 默认是不使用cookie管理器。</li>
<li><strong>执行器</strong>是<code>java.util.concurrent.Executor</code>接口的一个实例，用于发送和接收异步HTTP请求和响应。 如果未指定，则提供默认执行程序。</li>
<li><strong>重定向策略</strong>是<code>HttpClient.Redirect</code>枚举的常量，它指定如何处理服务器的重定向问题。 默认值NEVER，这意味着服务器发出的重定向不会被遵循。</li>
<li><strong>请求优先级</strong>是HTTP/2请求的默认优先级，可以在1到256（含）之间。 这是服务器优先处理请求的一个提示。 更高的值意味着更高的优先级。</li>
<li><strong>代理选择器</strong>是<code>java.net.ProxySelector</code>类的一个实例，用于选择要使用的代理服务器。 默认是不使用代理服务器。</li>
<li><strong>SSL上下文</strong>是提供安全套接字协议实现的<code>javax.net.ssl.SSLContext</code>类的实例。当不需要指定协议或不需要客户端身份验证时， 提供了一个默认的SSLContext，此选项将起作用。</li>
<li><strong>SSL参数</strong>是SSL/TLS/DTLS连接的参数。 它们保存在<code>javax.net.ssl.SSLParameters</code>类的实例中。</li>
<li><strong>HTTP版本</strong>是HTTP的版本，它是1.1或2.它被指定为<code>HttpClient.Version</code>枚举的常量：HTTP_1_1和HTTP_2。 它尽可能请求一个特定的HTTP协议版本。 默认值为HTTP_1_1。</li>
</ul>
<blockquote>
<p>Tips</p>
<p>HttpClient是不可变的。 当构建这样的请求时，存储在HttpClient中的一些配置可能会被HTTP请求覆盖。</p>
</blockquote>
<p>HttpClient类是抽象的，不能直接创建它的对象。 有两种方法可以创建一个HttpClient对象：</p>
<ul>
<li>使用HttpClient类的newHttpClient()静态方法</li>
<li>使用HttpClient.Builder类的build()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Get the default HttpClient</span><br><span class="line">HttpClient defaultClient = HttpClient.newHttpClient();</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>HttpClient.Builder</code>类创建HttpClient。 <code>HttpClient.newBuilder()</code>静态方法返回一个新的<code>HttpClient.Builder</code>类实例。 <code>HttpClient.Builder</code>类提供了设置每个配置值的方法。 配置的值被指定为方法的参数，该方法返回构建器对象本身的引用，因此可以链接多个方法。 最后，调用返回HttpClient对象的build()方法。 以下语句创建一个HttpClient，重定向策略设置为ALWAYS，HTTP版本设置为HTTP_2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a custom HttpClient</span></span><br><span class="line">HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">                      .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">                      .version(HttpClient.Version.HTTP_2)</span><br><span class="line">                      .build();</span><br></pre></td></tr></table></figure>
<p><code>HttpClient</code>类包含对应于每个配置设置的方法，该设置返回该配置的值。 这些方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;Authenticator&gt; <span class="title">authenticator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Optional&lt;CookieManager&gt; <span class="title">cookieManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Executor <span class="title">executor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">HttpClient.Redirect <span class="title">followRedirects</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Optional&lt;ProxySelector&gt; <span class="title">proxy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">SSLContext <span class="title">sslContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Optional&lt;SSLParameters&gt; <span class="title">sslParameters</span><span class="params">()</span></span></span><br><span class="line"><span class="function">HttpClient.Version <span class="title">version</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>请注意，<code>HttpClient</code>类中没有setter方法，因为它是不可变的。 不能使用HttpClient自己本身的对象。 在使用HttpClient对象向服务器发送请求之前，需要使用HttpRequest对象。HttpClient类包含以下三种向服务器发送请求的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">HttpResponse&lt;T&gt; <span class="title">send</span><span class="params">(HttpRequest req, HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; <span class="title">sendAsync</span><span class="params">(HttpRequest req, HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler)</span></span></span><br><span class="line"><span class="function">&lt;U,T&gt; CompletableFuture&lt;U&gt; <span class="title">sendAsync</span><span class="params">(HttpRequest req, HttpResponse.MultiProcessor&lt;U,T&gt; multiProcessor)</span></span></span><br></pre></td></tr></table></figure>
<p><code>send()</code>方法同步发送请求，而<code>sendAsync()</code>方法异步发送请求。</p>
<h2 id="四-处理HTTP请求"><a href="#四-处理HTTP请求" class="headerlink" title="四. 处理HTTP请求"></a>四. 处理HTTP请求</h2><p>客户端应用程序使用HTTP请求与Web服务器进行通信。 它向服务器发送一个请求，服务器发回对应的HTTP响应。 HttpRequest类的实例表示HTTP请求。 以下是处理HTTP请求所需执行的步骤：</p>
<ul>
<li>获取HTTP请求构建器（builder）</li>
<li>设置请求的参数</li>
<li>从构建器创建HTTP请求</li>
<li>将HTTP请求同步或异步发送到服务器</li>
<li>处理来自服务器的响应</li>
</ul>
<h3 id="1-获取HTTP请求构建器"><a href="#1-获取HTTP请求构建器" class="headerlink" title="1. 获取HTTP请求构建器"></a>1. 获取HTTP请求构建器</h3><p>需要使用构建器对象，该对象是<code>HttpRequest.Builder</code>类的实例来创建一个HttpRequest。 可以使用HttpRequest类的以下静态方法获取HttpRequest.Builder：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.<span class="function">Builder <span class="title">newBuilder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">newBuilder</span><span class="params">(URI uri)</span></span></span><br></pre></td></tr></table></figure>
<p>以下代码片段显示了如何使用这些方法来获取HttpRequest.Builder实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A URI to point to google</span></span><br><span class="line">URI googleUri = <span class="keyword">new</span> URI(<span class="string">"http://www.google.com"</span>);</span><br><span class="line"><span class="comment">// Get a builder for the google URI</span></span><br><span class="line">HttpRequest.Builder builder1 = HttpRequest.newBuilder(googleUri);</span><br><span class="line"><span class="comment">// Get a builder without specifying a URI at this time</span></span><br><span class="line">HttpRequest.Builder builder2 = HttpRequest.newBuilder();</span><br></pre></td></tr></table></figure>
<h3 id="2-设置HTTP请求参数"><a href="#2-设置HTTP请求参数" class="headerlink" title="2. 设置HTTP请求参数"></a>2. 设置HTTP请求参数</h3><p>拥有HTTP请求构建器后，可以使用构建器的方法为请求设置不同的参数。 所有方法返回构建器本身，因此可以链接它们。 这些方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.<span class="function">Builder <span class="title">DELETE</span><span class="params">(HttpRequest.BodyProcessor body)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">expectContinue</span><span class="params">(<span class="keyword">boolean</span> enable)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">GET</span><span class="params">()</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">header</span><span class="params">(String name, String value)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">headers</span><span class="params">(String... headers)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">method</span><span class="params">(String method, HttpRequest.BodyProcessor body)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">POST</span><span class="params">(HttpRequest.BodyProcessor body)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">PUT</span><span class="params">(HttpRequest.BodyProcessor body)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">setHeader</span><span class="params">(String name, String value)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">timeout</span><span class="params">(Duration duration)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">uri</span><span class="params">(URI uri)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">version</span><span class="params">(HttpClient.Version version)</span></span></span><br></pre></td></tr></table></figure>
<p>使用<code>HttpClient</code>将<code>HttpRequest</code>发送到服务器。 当构建HTTP请求时，可以使用<code>version()</code>方法通过HttpRequest.Builder对象设置HTTP版本值，该方法将在发送此请求时覆盖HttpClient中设置的HTTP版本。 以下代码片段将HTTP版本设置为2.0，以覆盖默认HttpClient对象中的NEVER的默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// By default a client uses HTTP 1.1. All requests sent using this</span></span><br><span class="line"><span class="comment">// HttpClient will use HTTP 1.1 unless overridden by the request</span></span><br><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// A URI to point to google</span></span><br><span class="line">URI googleUri = <span class="keyword">new</span> URI(<span class="string">"http://www.google.com"</span>);</span><br><span class="line"><span class="comment">// Get an HttpRequest that uses HTTP 2.0</span></span><br><span class="line">HttpRequest request = HttpRequest.newBuilder(googleUri)</span><br><span class="line">                                 .version(HttpClient.Version.HTTP_2)</span><br><span class="line">                                 .build();</span><br><span class="line"><span class="comment">// The client object contains HTTP version as 1.1 and the request</span></span><br><span class="line"><span class="comment">// object contains HTTP version 2.0. The following statement will</span></span><br><span class="line"><span class="comment">// send the request using HTTP 2.0, which is in the request object.</span></span><br><span class="line">HttpResponse&lt;String&gt; r = client.send(request, BodyHandler.asString());</span><br></pre></td></tr></table></figure>
<p><code>timeout()</code>方法指定请求的超时时间。 如果在指定的超时时间内未收到响应，则会抛出<code>HttpTimeoutException</code>异常。</p>
<p>HTTP请求可能包含名为expect的首部字段，其值为“100-Continue”。 如果设置了此首部字段，则客户端只会向服务器发送头文件，并且预计服务器将发回错误响应或100-Continue响应。 收到此响应后，客户端将请求主体发送到服务器。 在客户端发送实际请求体之前，客户端使用此技术来检查服务器是否可以基于请求的首部处理请求。 默认情况下，此首部字段未设置。 需要调用请求构建器的expectContinue(true)方法来启用此功能。 请注意，调用请求构建器的header(“expect”, “100-Continue”)方法不会启用此功能。 必须使用expectContinue(true)方法启用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Enable the expect=100-Continue header in the request</span><br><span class="line">HttpRequest.Builder builder = HttpRequest.newBuilder()                                                               </span><br><span class="line">                                         .expectContinue(true);</span><br></pre></td></tr></table></figure>
<h2 id="五-设置请求首部"><a href="#五-设置请求首部" class="headerlink" title="五. 设置请求首部"></a>五. 设置请求首部</h2><p>HTTP请求中的首部（header）是键值对的形式。 可以有多个首部字段。 可以使用<code>HttpRequest.Builder</code>类的<code>header()</code>，<code>headers()</code>和<code>setHeader()</code>方法向请求添加首部字段。 如果<code>header()</code>和<code>headers()</code>方法尚未存在，则会添加首部字段。 如果首部字段已经添加，这些方法什么都不做。 <code>setHeader()</code>方法如果存在，将替换首部字段； 否则，它会添加首部字段。</p>
<p><code>header()</code>和<code>setHeader()</code>方法允许一次添加/设置一个首部字段，而<code>headers()</code>方法可以添加多个。<code>headers()</code>方法采用一个可变参数，它应该按顺序包含键值对。 以下代码片段显示了如何为HTTP请求设置首部字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a URI</span></span><br><span class="line">URI calc = <span class="keyword">new</span> URI(<span class="string">"http://localhost:8080/webapp/Calculator"</span>);</span><br><span class="line"><span class="comment">// Use the header() method</span></span><br><span class="line">HttpRequest.Builder builder1 = HttpRequest.newBuilder(calc)</span><br><span class="line">    .header(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">    .header(<span class="string">"Accept"</span>, <span class="string">"text/plain"</span>);</span><br><span class="line"><span class="comment">// Use the headers() method</span></span><br><span class="line">HttpRequest.Builder builder2 = HttpRequest.newBuilder(calc)                </span><br><span class="line">    .headers(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>,</span><br><span class="line">             <span class="string">"Accept"</span>, <span class="string">"text/plain"</span>);</span><br><span class="line"><span class="comment">// Use the setHeader() method</span></span><br><span class="line">HttpRequest.Builder builder3 = HttpRequest.newBuilder(calc)                </span><br><span class="line">    .setHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">    .setHeader(<span class="string">"Accept"</span>, <span class="string">"text/plain"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="六-设置请求内容实体"><a href="#六-设置请求内容实体" class="headerlink" title="六. 设置请求内容实体"></a>六. 设置请求内容实体</h2><p>一些HTTP请求的主体包含使用POST和PUT方法的请求等数据。 使用主体处理器设置HTTP请求的内容实体，该体处理器是HttpRequest.BodyProcessor的静态嵌套接口。</p>
<p>HttpRequest.BodyProcessor接口包含以下静态工厂方法，它们返回一个HTTP请求的处理器，请求特定类型的资源（例如String，byte []或File）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.<span class="function">BodyProcessor <span class="title">fromByteArray</span><span class="params">(<span class="keyword">byte</span>[] buf)</span></span></span><br><span class="line"><span class="function">HttpRequest.BodyProcessor <span class="title">fromByteArray</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">HttpRequest.BodyProcessor <span class="title">fromByteArrays</span><span class="params">(Iterable&lt;<span class="keyword">byte</span>[]&gt; iter)</span></span></span><br><span class="line"><span class="function">HttpRequest.BodyProcessor <span class="title">fromFile</span><span class="params">(Path path)</span></span></span><br><span class="line"><span class="function">HttpRequest.BodyProcessor <span class="title">fromInputStream</span><span class="params">(Supplier&lt;? extends InputStream&gt; streamSupplier)</span></span></span><br><span class="line"><span class="function">HttpRequest.BodyProcessor <span class="title">fromString</span><span class="params">(String body)</span></span></span><br><span class="line"><span class="function">HttpRequest.BodyProcessor <span class="title">fromString</span><span class="params">(String s, Charset charset)</span></span></span><br></pre></td></tr></table></figure>
<p>这些方法的第一个参数表示请求的内容实体的数据源。 例如，如果String对象提供请求的内容实体，则使用fromString(String body)方法获取一个处理器。</p>
<blockquote>
<p>Tips</p>
<p><code>HttpRequest</code>类包含<code>noBody()</code>静态方法，该方法返回一个<code>HttpRequest.BodyProcessor</code>，它不处理请求内容实体。 通常，当HTTP方法不接受正文时，此方法可以与<code>method()</code>方法一起使用，但是<code>method()</code>方法需要传递一个实体处理器。</p>
</blockquote>
<p>一个请求是否可以拥有一个内容实体取决于用于发送请求的HTTP方法。 DELETE，POST和PUT方法都有一个实体，而GET方法则没有。<code>HttpRequest.Builder</code>类包含一个与HTTP方法名称相同的方法来设置请求的方法和实体。 例如，要使用POST方法与主体，构建器有<code>POST(HttpRequest.BodyProcessor body)</code>方法。</p>
<h2 id="七-创建HTTP请求"><a href="#七-创建HTTP请求" class="headerlink" title="七. 创建HTTP请求"></a>七. 创建HTTP请求</h2><p>创建HTTP请求只需调用<code>HttpRequest.Builder</code>上的<code>build()</code>方法，该方法返回一个<code>HttpRequest</code>对象。 以下代码段创建了使用HTTP GET方法的HttpRequest：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                                 .uri(<span class="keyword">new</span> URI(<span class="string">"http://www.google.com"</span>))</span><br><span class="line">                                 .GET()</span><br><span class="line">                                 .build();</span><br></pre></td></tr></table></figure>
<p>以下代码片段使用HTTP POST方法构建首部信息和内容实体的Http请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build the URI and the form’s data</span></span><br><span class="line">URI calc = <span class="keyword">new</span> URI(<span class="string">"http://localhost:8080/webapp/Calculator"</span>);               </span><br><span class="line">String formData = <span class="string">"n1="</span> + URLEncoder.encode(<span class="string">"10"</span>,<span class="string">"UTF-8"</span>) +</span><br><span class="line">                  <span class="string">"&amp;n2="</span> + URLEncoder.encode(<span class="string">"20"</span>,<span class="string">"UTF-8"</span>) +</span><br><span class="line">                  <span class="string">"&amp;op="</span> + URLEncoder.encode(<span class="string">"+"</span>,<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// Build the HttpRequest object</span></span><br><span class="line">HttpRequest request = HttpRequest.newBuilder(calc)   </span><br><span class="line">   .header(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">   .header(<span class="string">"Accept"</span>, <span class="string">"text/plain"</span>)   </span><br><span class="line">   .POST(HttpRequest.BodyProcessor.fromString(formData))</span><br><span class="line">   .build();</span><br></pre></td></tr></table></figure></p>
<p>请注意，创建HttpRequest对象不会将请求发送到服务器。 需要调用HttpClient类的send()或sendAsync()方法将请求发送到服务器。</p>
<p>以下代码片段使用HTTP HEAD请求方法创建一个HttpRequest对象。 请注意，它使用HttpRequest.Builder类的method()方法来指定HTTP方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest request =</span><br><span class="line">    HttpRequest.newBuilder(<span class="keyword">new</span> URI(<span class="string">"http://www.google.com"</span>))   </span><br><span class="line">               .method(<span class="string">"HEAD"</span>, HttpRequest.noBody())</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>
<p>还有许多其他HTTP方法，如HEAD和OPTIONS，它们没有HttpRequest.Builder类的相应方法。 该类包含一个可用于任何HTTP方法的method(String method, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.BodyProcessor body)。 当使用method()方法时，请确保以大写的方式指定方法名称，例如GET，POST，HEAD等。以下是这些方法的列表：</span><br><span class="line"></span><br><span class="line">HttpRequest.<span class="function">Builder <span class="title">DELETE</span><span class="params">(HttpRequest.BodyProcessor body)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">method</span><span class="params">(String method, HttpRequest.BodyProcessor body)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">POST</span><span class="params">(HttpRequest.BodyProcessor body)</span></span></span><br><span class="line"><span class="function">HttpRequest.Builder <span class="title">PUT</span><span class="params">(HttpRequest.BodyProcessor body)</span></span></span><br></pre></td></tr></table></figure>
<p>以下代码片段从String中设置HTTP请求的内容实体，通常在将HTML表单发布到URL时完成。 表单数据由三个n1，n2和op字段组成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">URI calc = <span class="keyword">new</span> URI(<span class="string">"http://localhost:8080/webapp/Calculator"</span>);</span><br><span class="line"><span class="comment">// Compose the form data with n1 = 10, n2 = 20. And op = +      </span></span><br><span class="line">String formData = <span class="string">"n1="</span> + URLEncoder.encode(<span class="string">"10"</span>,<span class="string">"UTF-8"</span>) +</span><br><span class="line">                  <span class="string">"&amp;n2="</span> + URLEncoder.encode(<span class="string">"20"</span>,<span class="string">"UTF-8"</span>) +</span><br><span class="line">                  <span class="string">"&amp;op="</span> + URLEncoder.encode(<span class="string">"+"</span>,<span class="string">"UTF-8"</span>)  ;</span><br><span class="line">HttpRequest.Builder builder = HttpRequest.newBuilder(calc)                </span><br><span class="line">    .header(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">    .header(<span class="string">"Accept"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">    .POST(HttpRequest.BodyProcessor.fromString(formData));</span><br></pre></td></tr></table></figure>
<h2 id="八-处理HTTP响应"><a href="#八-处理HTTP响应" class="headerlink" title="八. 处理HTTP响应"></a>八. 处理HTTP响应</h2><p>一旦拥有<code>HttpRequest</code>对象，可以将请求发送到服务器并同步或异步地接收响应。 <code>HttpResponse&lt;T&gt;</code>类的实例表示从服务器接收到的响应，其中类型参数T表示响应内容实体的类型，例如String，byte []或Path。 可以使用HttpRequest类的以下方法发送HTTP请求并接收HTTP响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">HttpResponse&lt;T&gt; <span class="title">send</span><span class="params">(HttpRequest req, HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; <span class="title">sendAsync</span><span class="params">(HttpRequest req, HttpResponse.BodyHandler&lt;T&gt; responseBodyHandler)</span></span></span><br><span class="line"><span class="function">&lt;U,T&gt; CompletableFuture&lt;U&gt; <span class="title">sendAsync</span><span class="params">(HttpRequest req, HttpResponse.MultiProcessor&lt;U,T&gt; multiProcessor)</span></span></span><br></pre></td></tr></table></figure>
<p><code>send()</code>方法是同步的。 也就是说，它会一直阻塞，直到收到响应。 <code>sendAsync()</code>方法异步处理响应。 它立即返回一个<code>CompletableFuture&lt;HttpResponse&gt;</code>，当响应准备好进行处理时，它就会完成。</p>
<h3 id="1-处理响应状态和首部"><a href="#1-处理响应状态和首部" class="headerlink" title="1. 处理响应状态和首部"></a>1. 处理响应状态和首部</h3><p>HTTP响应包含状态代码，响应首部和响应内容实体。 一旦从服务器接收到状态代码和首部，但在接收到正文之前，<code>HttpResponse</code>对象就可使用。 <code>HttpResponse</code>类的<code>statusCode()</code>方法返回响应的状态代码，类型为int。 <code>HttpResponse</code>类的<code>headers()</code>方法返回响应的首部，作为<code>HttpHeaders</code>接口的实例。 HttpHeaders接口包含以下方法，通过名称或所有首部方便地检索首部的值作为<code>Map &lt;String，List &lt;String &gt;&gt;</code>类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">allValues</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Optional&lt;String&gt; <span class="title">firstValue</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Optional&lt;Long&gt; <span class="title">firstValueAsLong</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">Map&lt;String,List&lt;String&gt;&gt; <span class="title">map</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>下面包含一个完整的程序，用于向google发送请求，并附上HEAD请求。 它打印接收到的响应的状态代码和首部。 你可能得到不同的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GoogleHeadersTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.http.client;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpResponse;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoogleHeadersTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URI googleUri = <span class="keyword">new</span> URI(<span class="string">"http://www.google.com"</span>);</span><br><span class="line">            HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">            HttpRequest request =</span><br><span class="line">                HttpRequest.newBuilder(googleUri)</span><br><span class="line">                           .method(<span class="string">"HEAD"</span>, HttpRequest.noBody())</span><br><span class="line">                           .build();</span><br><span class="line">            HttpResponse&lt;?&gt; response =</span><br><span class="line">              client.send(request, HttpResponse.BodyHandler.discard(<span class="keyword">null</span>));</span><br><span class="line">            <span class="comment">// Print the response status code and headers</span></span><br><span class="line">            System.out.println(<span class="string">"Response Status Code:"</span> +</span><br><span class="line">                               response.statusCode());</span><br><span class="line">            System.out.println(<span class="string">"Response Headers are:"</span>);</span><br><span class="line">            response.headers()</span><br><span class="line">                    .map()</span><br><span class="line">                    .entrySet()</span><br><span class="line">                    .forEach(System.out::println);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException | InterruptedException |</span><br><span class="line">                 IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Using incubator modules: jdk.incubator.httpclient</span><br><span class="line">Response Status Code:200</span><br><span class="line">Response Headers are:</span><br><span class="line">accept-ranges=[none]</span><br><span class="line">cache-control=[private, max-age=0]</span><br><span class="line">content-type=[text/html; charset=ISO-8859-1]</span><br><span class="line">date=[Sun, 26 Feb 2017 16:39:36 GMT]</span><br><span class="line">expires=[-1]</span><br><span class="line">p3p=[CP=&quot;This is not a P3P policy! See https://www.google.com/support/accounts/answer/151657?hl=en for more info.&quot;]</span><br><span class="line">server=[gws]</span><br><span class="line">set-cookie=[NID=97=Kmz52m8Zdf4lsNDsnMyrJomx_2kD7lnWYcNEuwPWsFTFUZ7yli6DbCB98Wv-SlxOfKA0OoOBIBgysuZw3ALtgJjX67v7-mC5fPv88n8VpwxrNcjVGCfFrxVro6gRNIrye4dAWZvUVfY28eOM; expires=Mon, 28-Aug-2017 16:39:36 GMT; path=/; domain=.google.com; HttpOnly]</span><br><span class="line">transfer-encoding=[chunked]</span><br><span class="line">vary=[Accept-Encoding]</span><br><span class="line">x-frame-options=[SAMEORIGIN]</span><br><span class="line">x-xss-protection=[1; mode=block]</span><br></pre></td></tr></table></figure>
<h3 id="2-处理响应内容实体"><a href="#2-处理响应内容实体" class="headerlink" title="2. 处理响应内容实体"></a>2. 处理响应内容实体</h3><p>处理HTTP响应的内容实体是两步过程：</p>
<ul>
<li>当使用HttpClient类的send()或sendAsync()方法发送请求时，需要指定响应主体处理程序，它是HttpResponse.BodyHandler<t>接口的实例。</t></li>
<li>当接收到响应状态代码和首部时，调用响应体处理程序的apply()方法。 响应状态代码和首部传递给apply()方法。 apply()方法返回HttpResponse.BodyProcessor接口的实例，它读取响应实体并将读取的数据转换为类型T。</li>
</ul>
<p>不要担心处理响应实体的这些细节。 提供了<code>HttpResponse.BodyHandler&lt;T&gt;</code>的几个实现。 可以使用HttpResponse.BodyHandler接口的以下静态工厂方法获取其不同类型参数T的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse.BodyHandler&lt;<span class="keyword">byte</span>[]&gt; asByteArray()</span><br><span class="line">HttpResponse.<span class="function">BodyHandler&lt;Void&gt; <span class="title">asByteArrayConsumer</span><span class="params">(Consumer&lt;Optional&lt;<span class="keyword">byte</span>[]&gt;&gt; consumer)</span></span></span><br><span class="line"><span class="function">HttpResponse.BodyHandler&lt;Path&gt; <span class="title">asFile</span><span class="params">(Path file)</span></span></span><br><span class="line"><span class="function">HttpResponse.BodyHandler&lt;Path&gt; <span class="title">asFile</span><span class="params">(Path file, OpenOption... openOptions)</span></span></span><br><span class="line"><span class="function">HttpResponse.BodyHandler&lt;Path&gt; <span class="title">asFileDownload</span><span class="params">(Path directory, OpenOption... openOptions)</span></span></span><br><span class="line"><span class="function">HttpResponse.BodyHandler&lt;String&gt; <span class="title">asString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">HttpResponse.BodyHandler&lt;String&gt; <span class="title">asString</span><span class="params">(Charset charset)</span></span></span><br><span class="line"><span class="function">&lt;U&gt; HttpResponse.BodyHandler&lt;U&gt; <span class="title">discard</span><span class="params">(U value)</span></span></span><br></pre></td></tr></table></figure>
<p>这些方法的签名足够直观，可以告诉你他们处理什么类型的响应实体。 例如，如果要将响应实体作为String获取，请使用asString()方法获取一个实体处理程序。 discard(U value)方法返回一个实体处理程序，它丢弃响应实体并返回指定的值作为主体。</p>
<p><code>HttpResponse&lt;T&gt;</code>类的<code>body()</code>方法返回类型为T的响应实体。</p>
<p>以下代码段向google发送GET请求，并以String形式检索响应实体。 这里忽略了了异常处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.incubator.http.HttpResponse.BodyHandler.asString;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Build the request</span></span><br><span class="line">HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                .uri(<span class="keyword">new</span> URI(<span class="string">"http://google.com"</span>))</span><br><span class="line">                .GET()</span><br><span class="line">                .build();</span><br><span class="line"><span class="comment">// Send the request and get a Response</span></span><br><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newHttpClient()</span><br><span class="line">                                          .send(request, asString());</span><br><span class="line"><span class="comment">// Get the response body and print it</span></span><br><span class="line">String body = response.body();</span><br><span class="line">System.out.println(body);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Using incubator modules: jdk.incubator.httpclient</span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">&lt;TITLE&gt;301 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;</span><br><span class="line">&lt;H1&gt;301 Moved&lt;/H1&gt;</span><br><span class="line">The document has moved</span><br><span class="line">&lt;A HREF=&quot;http://www.google.com/&quot;&gt;here&lt;/A&gt;.</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>
<p>该示例返回一个状态代码为301的响应正文，表示URL已经移动。 输出还包含移动的URL。 如果将HttpClient中的以下重定向策略设置为“ALWAYS”，则该请求将重新提交到已移动的URL。 以下代码片段可解决此问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The request will follow the redirects issues by the server       </span></span><br><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newBuilder()</span><br><span class="line">    .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">    .build()</span><br><span class="line">    .send(request, asString());</span><br></pre></td></tr></table></figure>
<p>下面包含一个完整的程序，它显示如何使用一个POST请求与内容实体，并异步处理响应。 源代码中的Web应用程序包含为Calculator的servlet。 Calculator servlet的源代码不会在这里显示。 servlet接受请求中的三个参数，命名为n1，n2和op，其中n1和n2是两个数字，op是一个运算符（+， - ，*或/）。 响应是一个纯文本，并包含了运算符及其结果。 程序中的URL假定你已在本机上部署了servlet，并且Web服务器正在端口8080上运行。如果这些假设不正确，请相应地修改程序。 如果servlet被成功调用，你将得到这里显示的输出。 否则，将获得不同的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CalculatorTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.http.client;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> jdk.incubator.http.HttpRequest.BodyProcessor.fromString;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpResponse;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URI calcUri =</span><br><span class="line">                <span class="keyword">new</span> URI(<span class="string">"http://localhost:8080/webapp/Calculator"</span>);</span><br><span class="line">            String formData = <span class="string">"n1="</span> + URLEncoder.encode(<span class="string">"10"</span>,<span class="string">"UTF-8"</span>) +</span><br><span class="line">                              <span class="string">"&amp;n2="</span> + URLEncoder.encode(<span class="string">"20"</span>,<span class="string">"UTF-8"</span>) +</span><br><span class="line">                              <span class="string">"&amp;op="</span> + URLEncoder.encode(<span class="string">"+"</span>,<span class="string">"UTF-8"</span>)  ;</span><br><span class="line">            <span class="comment">// Create a request</span></span><br><span class="line">            HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                .uri(calcUri)</span><br><span class="line">                .header(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">                .header(<span class="string">"Accept"</span>, <span class="string">"text/plain"</span>)                </span><br><span class="line">                .POST(fromString(formData))</span><br><span class="line">                .build();</span><br><span class="line">            <span class="comment">// Process the response asynchronously. When the response</span></span><br><span class="line">            <span class="comment">// is ready, the processResponse() method of this class will</span></span><br><span class="line">            <span class="comment">// be called.</span></span><br><span class="line">            HttpClient.newHttpClient()</span><br><span class="line">                      .sendAsync(request,</span><br><span class="line">                                 HttpResponse.BodyHandler.asString())</span><br><span class="line">                      .whenComplete(CalculatorTest::processResponse);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Let the current thread sleep for 5 seconds,</span></span><br><span class="line">                <span class="comment">// so the async response processing is complete</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (URISyntaxException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processResponse</span><span class="params">(HttpResponse&lt;String&gt; response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Throwable t)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (t == <span class="keyword">null</span> ) &#123;</span><br><span class="line">             System.out.println(<span class="string">"Response Status Code: "</span> +  </span><br><span class="line">                                 response.statusCode());</span><br><span class="line">             System.out.println(<span class="string">"Response Body: "</span> + response.body());</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"An exception occurred while "</span> +</span><br><span class="line">                <span class="string">"processing the HTTP request. Error: "</span> +  t.getMessage());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Using incubator modules: jdk.incubator.httpclient</span><br><span class="line">Response Status Code: 200</span><br><span class="line">Response Body: 10 + 20 = 30.0</span><br></pre></td></tr></table></figure>
<p>使用响应实体处理程序可以节省开发人员的大量工作。 在一个语句中，可以下载并将URL的内容保存在文件中。 以下代码片段将google的内容作为google.html的文件保存在当前目录中。 下载完成后，打印下载文件的路径。 如果发生错误，则会打印异常的堆栈跟踪。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HttpClient.newBuilder()</span><br><span class="line">          .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">          .build()</span><br><span class="line">          .sendAsync(HttpRequest.newBuilder()           </span><br><span class="line">                                .uri(<span class="keyword">new</span> URI(<span class="string">"http://www.google.com"</span>))</span><br><span class="line">                                .GET()</span><br><span class="line">                                .build(),</span><br><span class="line">                                asFile(Paths.get(<span class="string">"google.html"</span>)))</span><br><span class="line">           .whenComplete((HttpResponse&lt;Path&gt; response,</span><br><span class="line">                          Throwable exception) -&gt; &#123;</span><br><span class="line">               <span class="keyword">if</span>(exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"File saved to "</span> +</span><br><span class="line">                                     response.body().toAbsolutePath());</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  exception.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-处理响应的Trailer"><a href="#3-处理响应的Trailer" class="headerlink" title="3. 处理响应的Trailer"></a>3. 处理响应的Trailer</h3><p>HTTP Trailer是HTTP响应结束后由服务器发送的键值列表。 许多服务器通常不使用HTTP Trailer。 HttpResponse类包含一个trailers()方法，它作为CompletableFuture <httpheaders>的实例返回响应Trailer。 注意返回的对象类型的名称——HttpHeaders。 HTTP/2 Client API确实有一个名为HttpTrailers的类型。 需要检索响应实体，然后才能检索Trailer。 目前，HTTP/2 Client API不支持处理HTTP Trailer了。 以下代码片段显示了如何在API支持时打印所有响应Trailer：</httpheaders></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get an HTTP response</span></span><br><span class="line">HttpResponse&lt;String&gt; response = HttpClient.newBuilder()</span><br><span class="line">                  .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">                  .build()</span><br><span class="line">                  .send(HttpRequest.newBuilder()           </span><br><span class="line">                                   .uri(<span class="keyword">new</span> URI(<span class="string">"http://www.google.com"</span>))</span><br><span class="line">                                   .GET()</span><br><span class="line">                                   .build(),</span><br><span class="line">                                   asString());</span><br><span class="line"><span class="comment">// Read the response body</span></span><br><span class="line">String body = response.body();</span><br><span class="line"><span class="comment">// Process trailers</span></span><br><span class="line">response.trailers()</span><br><span class="line">        .whenComplete((HttpHeaders trailers, Throwable t) -&gt; &#123;</span><br><span class="line">             <span class="keyword">if</span>(t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 trailers.map()</span><br><span class="line">                         .entrySet()</span><br><span class="line">                         .forEach(System.out::println);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  t.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="九-设置请求重定向策略"><a href="#九-设置请求重定向策略" class="headerlink" title="九. 设置请求重定向策略"></a>九. 设置请求重定向策略</h2><p>一个HTTP请求对应的响应，Web服务器可以返回3XX响应状态码，其中X是0到9之间的数字。该状态码表示客户端需要执行附加操作才能完成请求。 例如，状态代码为301表示URL已被永久移动到新位置。 响应实体包含替代位置。 默认情况下，在收到3XX状态代码后，请求不会重新提交到新位置。 可以将HttpClient.Redirect枚举的以下常量设置为HttpClient执行的策略，以防返回的响应包含3XX响应状态代码：</p>
<ul>
<li><strong>ALWAYS</strong>指示应始终遵循重定向。 也就是说，请求应该重新提交到新的位置。</li>
<li><strong>NEVER</strong>表示重定向不应该被遵循。 这是默认值。</li>
<li><strong>SAME_PROTOCOL</strong>表示如果旧位置和新位置使用相同的协议（例如HTTP到HTTP或HTTPS到HTTPS），则可能会发生重定向。</li>
<li><strong>SECURE</strong>表示重定向应始终发生，除非旧位置使用HTTPS，而新的位置使用了HTTP。</li>
</ul>
<h2 id="十-使用WebSocket协议"><a href="#十-使用WebSocket协议" class="headerlink" title="十. 使用WebSocket协议"></a>十. 使用WebSocket协议</h2><p>WebSocket协议在两个endpoint（客户端endpoint和服务器endpoint）之间提供双向通信。 endpoint 是指使用WebSocket协议的连接的两侧中的任何一个。 客户端endpoint启动连接，服务器端点接受连接。 连接是双向的，这意味着服务器endpoint可以自己将消息推送到客户端端点。 在这种情况下，也会遇到另一个术语，称为对等体(peer)。 对等体只是连接的另一端。 例如，对于客户端endpoint，服务器endpoint是对等体，对于服务器endpoint，客户端endpoint是对等体。 WebSocket会话表示endpoint和单个对等体之间的一系列交互。</p>
<p>WebSocket协议可以分为三个部分：</p>
<ul>
<li>打开握手</li>
<li>数据交换</li>
<li>关闭握手</li>
</ul>
<p>客户端发起与与服务器的打开握手。 使用HTTP与WebSocket协议的升级请求进行握手。 服务器通过升级响应响应打开握手。 握手成功后，客户端和服务器交换消息。 消息交换可以由客户端或服务器发起。 最后，任一endpoint都可以发送关闭握手; 对方以关闭握手回应。 关闭握手成功后，WebSocket关闭。</p>
<p>JDK 9中的HTTP/2 Client API支持创建WebSocket客户端endpoint。 要拥有使用WebSocket协议的完整示例，需要具有服务器endpoint和客户端endpoint。 以下部分涵盖了创建两者。</p>
<h3 id="1-创建服务器端Endpoint"><a href="#1-创建服务器端Endpoint" class="headerlink" title="1. 创建服务器端Endpoint"></a>1. 创建服务器端Endpoint</h3><p>创建服务器Endpoint需要使用Java EE。 将简要介绍如何创建一个服务器Endpoint示例中使用。 使用Java EE 7注解创建一个WebSocket服务器Endpoint。</p>
<p>下面包含TimeServerEndPoint类的代码。 该类包含在源代码的webapp目录中的Web应用程序中。 将Web应用程序部署到Web服务器时，此类将部署为服务器Endpoint。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TimeServerEndPoint.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.ws;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.CloseReason;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnError;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javax.websocket.CloseReason.CloseCodes.NORMAL_CLOSURE;</span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/servertime"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerEndPoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span> </span>&#123;                </span><br><span class="line">        System.out.println(<span class="string">"Client connected. "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Session session)</span> </span>&#123;        </span><br><span class="line">        System.out.println(<span class="string">"Connection closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable t)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Error occurred:"</span> + t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client: "</span> + message);                </span><br><span class="line">        <span class="comment">// Send messages to the client</span></span><br><span class="line">        sendMessages(session);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessages</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Start a new thread and send 3 messages to the</span></span><br><span class="line"><span class="comment">           client. Each message contains the current date and</span></span><br><span class="line"><span class="comment">           time with zone.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                String currentTime =</span><br><span class="line">                    ZonedDateTime.now().toString();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    session.getBasicRemote()</span><br><span class="line">                           .sendText(currentTime, <span class="keyword">true</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(InterruptedException | IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Let us close the WebSocket</span></span><br><span class="line">                session.close(<span class="keyword">new</span> CloseReason(NORMAL_CLOSURE,</span><br><span class="line">                                              <span class="string">"Done"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>TimeServerEndPoint</code>类上使用<code>@ServerEndpoint(&quot;/servertime&quot;)</code>注解使该类成为服务器Endpoint，当它部署到Web服务器时。注解value元素的值为<code>/servertime</code>，这将使Web服务器在此URL发布此Endpoint。</p>
<p>该类包含四个方法，它们已经添加了@onOpen，@onMessage，@onClose和@onError注解。 命名这些方法的名字与这些注解相同。 这些方法在服务器Endpoint的生命周期的不同点被调用。 他们以Session对象为参数。 Session对象表示此Endpoint与其对等体的交互，这将是客户端。</p>
<p>当与对等体进行握手成功时，将调用onOpen()方法。 该方法打印客户端连接的消息。</p>
<p>当从对等体接收到消息时，会调用onMessage()。 该方法打印它接收的消息，并调用一个名为sendMessages()的私有方法。 sendMessages()方法启动一个新线程，并向对等体发送三条消息。 线程在发送每条消息后休眠五秒钟。 该消息包含当前日期和时间与时区。 可以同步或异步地向对等体发送消息。 要发送消息，需要获得表示与对等体的会话的RemoteEndpoint接口的引用。 在Session实例上使用getBasicRemote()和getAsyncRemote()方法来获取可以分别同步和异步发送消息的RemoteEndpoint.Basic和RemoteEndpont.Async实例。 一旦得到了对等体（远程endpoint）的引用，可以调用其几个sendXxx()方法来向对等体发送不同类型的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send a synchronous text message to the peer</span></span><br><span class="line">session.getBasicRemote()</span><br><span class="line">       .sendText(currentTime, <span class="keyword">true</span>);</span><br><span class="line">sendText()</span><br></pre></td></tr></table></figure>
<p>方法中的第二个参数指示是否是发送的部分消息的最后一部分。 如果消息完成，请使用true。</p>
<p>在所有消息发送到对等体后，使用sendClose()方法发送关闭消息。 该方法接收封闭了一个关闭代码和一个紧密原因的CloseReason类的对象。 当对等体收到一个关闭消息时，对等体需要响应一个关闭消息，之后WebSocket连接被关闭。</p>
<p>请注意，在发送关闭消息后，服务器endpoint不应该向对等体发送更多消息。</p>
<p>当出现错误而不是由WebSocket协议处理时，会调用onError()方法。</p>
<p>不能单独使用此endpoint。 需要创建一个客户端endpoint，将在下一节中详细介绍。</p>
<h3 id="2-创建客户端Endpoint"><a href="#2-创建客户端Endpoint" class="headerlink" title="2. 创建客户端Endpoint"></a>2. 创建客户端Endpoint</h3><p>开发WebSocket客户端Endpoint涉及使用WebSocket接口，它是JDK 9中的HTTP/2 Client API的一部分。WebSocket接口包含以下嵌套类型：</p>
<ul>
<li>WebSocket.Builder</li>
<li>WebSocket.Listener</li>
<li>WebSocket.MessagePart</li>
</ul>
<p>WebSocket接口的实例表示一个WebSocket客户端endpoint。 构建器，它是WebSocket.Builder接口的实例，用于创建WebSocket实例。 HttpClient类的<code>newWebSocketBuilder(URI uri, WebSocket.Listener listener)</code>方法返回一个WebSocket.Builder接口的实例。</p>
<p>当事件发生在客户端endpoint时，例如，完成开启握手，消息到达，关闭握手等，通知被发送到一个监听器，该监听器是WebSocket.Listener接口的实例。 该接口包含每种通知类型的默认方法。 需要创建一个实现此接口的类。 仅实现与接收通知的事件相对应的那些方法。 创建·WebSocket·实例时，需要指定监听器。</p>
<p>当向对等体发送关闭消息时，可以指定关闭状态代码。 WebSocket接口包含以下可以用作WebSocket关闭消息状态代码的int类型常量：</p>
<ul>
<li><strong>CLOSED_ABNORMALLY</strong>：表示WebSocket关闭消息状态代码（1006），这意味着连接异常关闭，例如，没有发送或接收到关闭消息。</li>
<li><strong>NORMAL_CLOSURE</strong>：表示WebSocket关闭消息状态代码（1000），这意味着连接正常关闭。 这意味着建立连接的目的已经实现了。</li>
</ul>
<p>服务器Endpoint可能会发送部分消息。 消息被标记为开始，部分，最后或全部，表示其位置。 WebSocket.MessagePart枚举定义了与消息的位置相对应的四个常量：FIRST，PART，LAST和WHOLE。 当监听器收到已收到消息的通知时，将这些值作为消息的一部分。</p>
<p>以下部分将详细介绍设置客户端Endpoint的各个步骤。</p>
<h2 id="十一-创建监听器"><a href="#十一-创建监听器" class="headerlink" title="十一. 创建监听器"></a>十一. 创建监听器</h2><p>监听器是WebSocket.Listener接口的实例。 创建监听器涉及创建实现此接口的类。 该接口包含以下默认方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage&lt;?&gt; onBinary(WebSocket webSocket, ByteBuffer message, WebSocket.MessagePart part)</span><br><span class="line">CompletionStage&lt;?&gt; onClose(WebSocket webSocket, <span class="keyword">int</span> statusCode, String reason)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(WebSocket webSocket, Throwable error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(WebSocket webSocket)</span></span></span><br><span class="line"><span class="function">CompletionStage&lt;?&gt; <span class="title">onPing</span><span class="params">(WebSocket webSocket, ByteBuffer message)</span></span></span><br><span class="line"><span class="function">CompletionStage&lt;?&gt; <span class="title">onPong</span><span class="params">(WebSocket webSocket, ByteBuffer message)</span></span></span><br><span class="line"><span class="function">CompletionStage&lt;?&gt; <span class="title">onText</span><span class="params">(WebSocket webSocket, CharSequence message, WebSocket.MessagePart part)</span></span></span><br></pre></td></tr></table></figure>
<p>当客户端Endpoint连接到引用传递给该方法的对等体作为第一个参数时，调用onOpen()方法。 默认实现请求一个消息，这意味着该侦听器可以再接收一条消息。 消息请求是使用WebSocket接口的request(long n)方法进行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allow one more message to be received</span></span><br><span class="line">webSocket.request(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>如果服务器发送的消息多于请求消息，则消息在TCP连接上排队，最终可能强制发送方通过TCP流控制停止发送更多消息。 请在适当的时间调用request(long n)方法并使用适当的参数值，这样监听器就不会从服务器一直接收消息。 在监听器中重写onOpen()方法是一个常见的错误，而不是调用webSocket.request(1)方法，后者会阻止从服务器接收消息。</p>
<p>当endpoint收到来自对等体的关闭消息时，调用onClose()方法。 这是监听器的最后通知。 从此方法抛出的异常将被忽略。 默认的实现不会做任何事情。 通常，需要向对方发送一条关闭消息，以完成关闭握手。</p>
<p>当endpoint从对等体接收到Ping消息时，调用onPing()方法。 Ping消息可以由客户端和服务器endpoint发送。 默认实现将相同消息内容的Pong消息发送给对等体。</p>
<p>当endpoint从对等体接收到Pong消息时，调用onPong()方法。 通常作为对先前发送的Ping消息的响应来接收Pong消息。 endpoint也可以接收未经请求的Pong消息。 onPong()方法的默认实现在监听器上再请求一个消息，不执行其他操作。</p>
<p>当WebSocket上发生I/O或协议错误时，会调用onError()方法。 从此方法抛出的异常将被忽略。 调用此方法后，监听器不再收到通知。 默认实现什么都不做。</p>
<p>当从对等体接收到二进制消息和文本消息时，会调用onBinary()和onText()方法。 确保检查这些方法的最后一个参数，这表示消息的位置。 如果收到部分消息，需要组装它们以获取整个消息。 从这些方法返回null表示消息处理完成。 否则，返回CompletionStage&lt;?&gt;，并在消息处理完成后完成。</p>
<p>以下代码段创建一个可以接收信息的WebSocket监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WebSocket.Listener listener =  <span class="keyword">new</span> WebSocket.Listener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletionStage&lt;?&gt; onText(WebSocket webSocket,</span><br><span class="line">                                     CharSequence message,</span><br><span class="line">                                     WebSocket.MessagePart part) &#123;</span><br><span class="line">        <span class="comment">// Allow one message to be received by the listener</span></span><br><span class="line">        webSocket.request(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Print the message received from the server</span></span><br><span class="line">        System.out.println(<span class="string">"Server: "</span> + message);</span><br><span class="line">        <span class="comment">// Return null indicating that we are done processing this message</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="十二-构建Endpoint"><a href="#十二-构建Endpoint" class="headerlink" title="十二. 构建Endpoint"></a>十二. 构建Endpoint</h2><p>需要构建充当客户端点的WebSocket接口的实例。 该实例用于与服务器Endpoint连接和交换消息。 WebSocket实例使用WebSocket.Builder构建。 可以使用HttpClient类的以下方法获取构建器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebSocket.<span class="function">Builder <span class="title">newWebSocketBuilder</span><span class="params">(URI uri, WebSocket.Listener listener)</span></span></span><br></pre></td></tr></table></figure>
<p>用于获取WebSocket构建器的HttpClient实例提供了WebSocket的连接配置。 指定的uri是服务器Endpoint的URI。 监听器是正在构建的Endpoint的监听器， 拥有构建器后，可以调用以下方法来配置endpoint：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebSocket.<span class="function">Builder <span class="title">connectTimeout</span><span class="params">(Duration timeout)</span></span></span><br><span class="line"><span class="function">WebSocket.Builder <span class="title">header</span><span class="params">(String name, String value)</span></span></span><br><span class="line"><span class="function">WebSocket.Builder <span class="title">subprotocols</span><span class="params">(String mostPreferred, String... lesserPreferred)</span></span></span><br></pre></td></tr></table></figure>
<p><code>connectTimeout()</code>方法允许指定开启握手的超时时间。 如果开放握手在指定的持续时间内未完成，则从<code>WebSocket.Builder</code>的<code>buildAsync()</code>方法完成后返回带有异常的<code>HttpTimeoutException</code>的<code>CompletableFuture</code>。 可以使用<code>header()</code>方法添加任何用于打开握手的自定义首部。 可以使用<code>subprotocols()</code>方法在打开握手期间指定给定子协议的请求 —— 只有其中一个将被服务器选择。 子协议由应用程序定义。 客户端和服务器需要同意处理特定的子协议及其细节。</p>
<p>最后，调用<code>WebSocket.Builder</code>接口的<code>buildAsync()</code>方法来构建<code>Endpoint</code>。 它返回<code>CompletableFuture &lt;WebSocket&gt;</code>，当该Endpoint连接到服务器Endpoint时，正常完成； 当有错误时，返回异常。 以下代码片段显示了如何构建和连接客户端Endpoint。 请注意，服务器的URI以ws开头，表示WebSocket协议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URI serverUri = <span class="keyword">new</span> URI(<span class="string">"ws://localhost:8080/webapp/servertime"</span>);</span><br><span class="line"><span class="comment">// Get a listener</span></span><br><span class="line">WebSocket.Listener listener = ...;</span><br><span class="line"><span class="comment">// Build an endpoint using the default HttpClient</span></span><br><span class="line">HttpClient.newHttpClient()</span><br><span class="line">          .newWebSocketBuilder(serverUri, listener)</span><br><span class="line">          .buildAsync()</span><br><span class="line">          .whenComplete((WebSocket webSocket, Throwable t) -&gt; &#123;</span><br><span class="line">               <span class="comment">// More code goes here</span></span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="十三-向对等体发送消息"><a href="#十三-向对等体发送消息" class="headerlink" title="十三. 向对等体发送消息"></a>十三. 向对等体发送消息</h2><p>一旦客户端Endpoint连接到对等体，则交换消息。 WebSocket接口的实例表示一个客户端Endpoint，该接口包含以下方法向对等体发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletableFuture&lt;WebSocket&gt; <span class="title">sendBinary</span><span class="params">(ByteBuffer message, <span class="keyword">boolean</span> isLast)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;WebSocket&gt; <span class="title">sendClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;WebSocket&gt; <span class="title">sendClose</span><span class="params">(<span class="keyword">int</span> statusCode, String reason)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;WebSocket&gt; <span class="title">sendPing</span><span class="params">(ByteBuffer message)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;WebSocket&gt; <span class="title">sendPong</span><span class="params">(ByteBuffer message)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;WebSocket&gt; <span class="title">sendText</span><span class="params">(CharSequence message)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;WebSocket&gt; <span class="title">sendText</span><span class="params">(CharSequence message, <span class="keyword">boolean</span> isLast)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>sendText()</strong>方法用于向对等体发送信息。 如果发送部分消息，请使用该方法的两个参数的版本。 如果第二个参数为false，则表示部分消息的一部分。 如果第二个参数为true，则表示部分消息的最后部分。 如果以前没有发送部分消息，则第二个参数中的true表示整个消息。</li>
<li><strong>endText(CharSequence message)</strong>是一种便捷的方法，它使用true作为第二个参数来调用该方法的第二个版本。</li>
<li><strong>sendBinary()</strong>方法向对等体发送二进制信息。</li>
<li><strong>sendPing()</strong>和<strong>sendPong()</strong>方法分别向对等体发送Ping和Pong消息。</li>
<li><strong>sendClose()</strong>方法向对等体发送Close消息。 可以发送关闭消息作为由对等方发起的关闭握手的一部分，或者可以发送它来发起与对等体的闭合握手。</li>
</ul>
<blockquote>
<p>Tips</p>
<p>如果想要突然关闭WebSocket，请使用WebSocket接口的<code>abort()</code>方法。</p>
</blockquote>
<h3 id="1-运行WebSocket程序"><a href="#1-运行WebSocket程序" class="headerlink" title="1. 运行WebSocket程序"></a>1. 运行WebSocket程序</h3><p>现在是查看WebSocket客户端endpoint和WebSocket服务器endpoint交换消息的时候了。下面包含一个封装客户机endpoint的WebSocketClient类的代码。 其用途如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a client WebSocket</span></span><br><span class="line">WebSocketClient wsClient = <span class="keyword">new</span> WebSocketClient(<span class="keyword">new</span> URI(“&lt;server-uri&gt;”));</span><br><span class="line"><span class="comment">// Connect to the server and exchange messages</span></span><br><span class="line">wsClient.connect();</span><br><span class="line"><span class="comment">// WebSocketClient.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.http.client;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletionStage;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> jdk.incubator.http.WebSocket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WebSocket webSocket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URI serverUri;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> inError = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketClient</span><span class="params">(URI serverUri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverUri = serverUri;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (webSocket != <span class="keyword">null</span> &amp;&amp; webSocket.isClosed())</span><br><span class="line">               ||</span><br><span class="line">               <span class="keyword">this</span>.inError;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpClient.newHttpClient()</span><br><span class="line">                  .newWebSocketBuilder(serverUri, <span class="keyword">this</span>.getListener())</span><br><span class="line">                  .buildAsync()</span><br><span class="line">                  .whenComplete(<span class="keyword">this</span>::statusChanged);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">statusChanged</span><span class="params">(WebSocket webSocket, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webSocket = webSocket;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;        </span><br><span class="line">            <span class="keyword">this</span>.talkToServer();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.inError = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"Could not connect to the server."</span> +</span><br><span class="line">                               <span class="string">" Error: "</span> + t.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">talkToServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Allow one message to be received by the listener</span></span><br><span class="line">        webSocket.request(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Send the server a request for time</span></span><br><span class="line">        webSocket.sendText(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> WebSocket.<span class="function">Listener <span class="title">getListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebSocket.Listener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(WebSocket webSocket)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Allow one more message to be received by the listener</span></span><br><span class="line">                webSocket.request(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// Notify the user that we are connected</span></span><br><span class="line">                System.out.println(<span class="string">"A WebSocket has been opened."</span>);                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> CompletionStage&lt;?&gt; onClose(WebSocket webSocket,</span><br><span class="line">                             <span class="keyword">int</span> statusCode, String reason) &#123;</span><br><span class="line">                <span class="comment">// Server closed the web socket. Let us respond to</span></span><br><span class="line">                <span class="comment">// the close message from the server</span></span><br><span class="line">                webSocket.sendClose();</span><br><span class="line">                System.out.println(<span class="string">"The WebSocket is closed."</span> +</span><br><span class="line">                                   <span class="string">" Close Code: "</span> + statusCode +</span><br><span class="line">                                   <span class="string">", Close Reason: "</span> + reason);</span><br><span class="line">                <span class="comment">// Return null indicating that this WebSocket</span></span><br><span class="line">                <span class="comment">// can be closed immediately</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(WebSocket webSocket, Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"An error occurred: "</span> + t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> CompletionStage&lt;?&gt; onText(WebSocket WebSocket,</span><br><span class="line">                CharSequence message, WebSocket.MessagePart part) &#123;</span><br><span class="line">                <span class="comment">// Allow one more message to be received by the listener</span></span><br><span class="line">                webSocket.request(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// Print the message received from the server</span></span><br><span class="line">                System.out.println(<span class="string">"Server: "</span> + message);</span><br><span class="line">                <span class="comment">// Return null indicating that we are done</span></span><br><span class="line">                <span class="comment">// processing this message</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WebSocketClient类的工作原理如下：</p>
<ul>
<li><code>webSocket</code>实例变量保存客户端endpoint的引用。</li>
<li><code>serverUri</code>实例变量保存服务器端endpoint的URI。</li>
<li><code>isError</code>实例变量保存一个指示符，无论该endpoint 是否出错。</li>
<li><code>isClosed()</code>方法检查endpoint 是否已经关闭或出错。</li>
<li>在开启握手成功之前，webSocket实例变量置为null。 它的值在statusChanged()方法中更新。</li>
<li><code>connect()</code>方法构建一个WebSocket并启动一个开始握手。 请注意，无论连接状态如何，它在开始握手完成后调用statusChanged()方法。</li>
<li>当开始握手成功时，tatusChanged()方法通过调用talkToServer()方法与服务器通信。 否则，它会打印一条错误消息，并将isError标志设置为true。</li>
<li><code>talkToServer()</code>方法允许监听器再接收一个消息，并向服务器endpoint发送一条信息。 请注意，服务器endpoint从客户端endpoint接收到信息时，会以五秒的间隔发送三个消息。 从talkToServer()方法发送此消息将启动两个endpoint之间的消息交换。</li>
<li><code>getListener()</code>方法创建并返回一个<code>WebSocket.Listener</code>实例。 服务器endpoint将发送三个消息，后跟一个关闭消息。 监听器中的onClose()方法通过发送一个空的关闭消息来响应来自服务器的关闭消息，这将结束客户端endpoint操作。</li>
</ul>
<p>如下包含运行客户端endpoint的程序。 如果运行WebSocketClientTest类，请确保具有服务器endpoint的Web应用程序正在运行。 还需要修改SERVER_URI静态变量以匹配Web应用程序的服务器endpoint的URI。 输出将使用时区打印当前日期和时间，因此可能会得到不同的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebSocketClientTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.http.client;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketClientTest</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// Please change the URI to point to your server endpoint</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_URI =<span class="string">"ws://localhost:8080/webapp/servertime"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> URISyntaxException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// Create a client WebSocket</span></span><br><span class="line">        WebSocketClient wsClient = <span class="keyword">new</span> WebSocketClient(<span class="keyword">new</span> URI(SERVER_URI));</span><br><span class="line">        <span class="comment">// Connect to the Server</span></span><br><span class="line">        wsClient.connect();</span><br><span class="line">        <span class="comment">// Wait until the WebSocket is closed</span></span><br><span class="line">        <span class="keyword">while</span>(!wsClient.isClosed()) &#123;            </span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Need to exit</span></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A WebSocket has been opened.</span><br><span class="line">Server: 2016-12-15T14:19:53.311-06:00[America/Chicago]</span><br><span class="line">Server: 2016-12-15T14:19:58.312-06:00[America/Chicago]</span><br><span class="line">Server: 2016-12-15T14:20:03.313-06:00[America/Chicago]</span><br><span class="line">The WebSocket is closed.  Close Code: 1000, Close Reason: Done</span><br></pre></td></tr></table></figure>
<h3 id="2-WebSocket应用程序疑难解答"><a href="#2-WebSocket应用程序疑难解答" class="headerlink" title="2. WebSocket应用程序疑难解答"></a>2. WebSocket应用程序疑难解答</h3><p>当测试WebSocket应用程序时，会出现一些问题。 下表列出了一些这些问题及其解决方案。</p>
<table>
<thead>
<tr>
<th>错误信息</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>Could not connect to the server. Error: java.net.ConnectException: Connection refused: no further information</td>
<td>表示Web服务器未运行或服务器URI不正确。 尝试运行Web服务器并检查在WebSocketClientTest类中其SERVER_URI静态变量的指定的服务器URI。</td>
</tr>
<tr>
<td>Could not connect to the server. Error: java.net.http.WebSocketHandshakeException: 404: RFC 6455 1.3. Unable to complete handshake; HTTP response status code 404</td>
<td>表示服务器URI未指向服务器上的正确endpoint 。 验证WebSocketClientTest类中SERVER_URI静态变量的值是否正确。</td>
</tr>
<tr>
<td>A WebSocket has been opened. Dec 15, 2016 2:58:03 PM java.net.http.WS$1 onError WARNING: Failing connection java.net.http.WS@162532d6[CONNECTED], reason: ‘RFC 6455 7.2.1. Stream ended before a Close frame has been received’ An error occurred: null</td>
<td>表示开启握手后，服务器将自动关闭服务器endpoint。 这通常由计算机上运行的防病毒程序执行的。 需要配置防病毒程序以允许指定端口上的HTTP连接，或者在另一个未被防病毒程序阻止的端口上使用HTTP监听器运行Web服务器。</td>
</tr>
<tr>
<td>A WebSocket has been opened. Server: 2016-12-16T07:15:04.586-06:00[America/Chicago]</td>
<td>在这种情况下，应用程序会打印一行或两行输出并一直等待。 当在客户端endpoint逻辑中没有webSocket.request(1)调用时，会发生这种情况。 服务器正在发送消息，因为不允许更多消息排队。 在onOpen，onText和其他事件中调用request(n)方法来解决这个问题。</td>
</tr>
</tbody>
</table>
<h2 id="十四-总结"><a href="#十四-总结" class="headerlink" title="十四. 总结"></a>十四. 总结</h2><p>JDK 9添加了一个<code>HTTP/2 Client API</code>，可以在Java应用程序中使用HTTP请求和响应。 API提供类和接口来开发具有身份验证和TLS的WebSocket客户端。 API位于jdk.incubator.http包中，该包位于<code>jdk.incubator.httpclient</code>模块中。</p>
<p>三个抽象类，<code>HttpClient</code>，<code>HttpRequest</code>和<code>HttpResponse</code>，<code>WebSocket</code>接口是HTTP/2 Client API的核心。这些类型的实例使用构建器创建。 HttpClient类是不可变的。HttpClient类的实例保存可以重复用于多个HTTP请求的HTTP连接配置。 HttpRequest类实例表示HTTP请求。 HttpResponse类的实例表示从服务器接收的HTTP响应。可以同步或异步地发送和接收HTTP请求和响应。</p>
<p>WebSocket接口的实例表示一个WebSocket客户端endpoint。与WebSocket服务器端endpoint的通信是异步完成的。 WebSocket API是基于事件的。需要为WebSocket客户端endpoint指定一个监听器，它是WebSocket.Listener接口的一个实例。监听器通过调用其适当的方法 —— 当事件发生在endpoint上时，例如，当通过调用监听器的onOpen()方法成功完成与对等体的打开握手时，通知监听器。 API支持与对等体交换文本以及二进制消息。消息可以部分交换。</p>
</div><p class="readmore"><a href="http://blog.oneforce.cn/online-markdown/?path=https://raw.githubusercontent.com/oneforce/oneforce.github.io/blog/source/_posts/Java/Java 9 Revealed/Chapter 14 HTTP2 Client API.md">在微信markdown中展示</a></p><div class="tags"><a href="/tags/Java9/">Java9</a><a href="/tags/http-2/">http/2</a></div><div class="post-nav"><a class="pre" href="/2018/03/06/Java/SpringBoot2/10. Installing Spring Boot/">&lt;&lt;Spring Boot 2&gt;&gt; 10. Installing Spring Boot</a><a class="next" href="/2018/03/05/Java/Spring Boot 2.0 Release Notes/">Spring Boot 2 Release Notes</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://oneforce.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-9-Revealed/">Java 9 Revealed</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Revealed/">Java Revealed</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot2/">SpringBoot2</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/参考文档/">参考文档</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/征信/">征信</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/私募基金/">私募基金</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/资产管理/">资产管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/金融法规/">金融法规</a><span class="category-list-count">15</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/入门系列/" style="font-size: 15px;">入门系列</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/spring-boot/" style="font-size: 15px;">spring boot</a> <a href="/tags/合规/" style="font-size: 15px;">合规</a> <a href="/tags/征信/" style="font-size: 15px;">征信</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/utf8/" style="font-size: 15px;">utf8</a> <a href="/tags/字符集/" style="font-size: 15px;">字符集</a> <a href="/tags/上海/" style="font-size: 15px;">上海</a> <a href="/tags/汽车/" style="font-size: 15px;">汽车</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/金融/" style="font-size: 15px;">金融</a> <a href="/tags/上海市互联网金融行业协会/" style="font-size: 15px;">上海市互联网金融行业协会</a> <a href="/tags/网络借贷/" style="font-size: 15px;">网络借贷</a> <a href="/tags/P2P/" style="font-size: 15px;">P2P</a> <a href="/tags/金融办/" style="font-size: 15px;">金融办</a> <a href="/tags/2018/" style="font-size: 15px;">2018</a> <a href="/tags/指引/" style="font-size: 15px;">指引</a> <a href="/tags/电子合同存证/" style="font-size: 15px;">电子合同存证</a> <a href="/tags/金融科技/" style="font-size: 15px;">金融科技</a> <a href="/tags/银监会/" style="font-size: 15px;">银监会</a> <a href="/tags/资产管理/" style="font-size: 15px;">资产管理</a> <a href="/tags/现金贷/" style="font-size: 15px;">现金贷</a> <a href="/tags/Java9/" style="font-size: 15px;">Java9</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/stream/" style="font-size: 15px;">stream</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/Spring-Boot-2/" style="font-size: 15px;">Spring Boot 2</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/原则/" style="font-size: 15px;">原则</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/p2p/" style="font-size: 15px;">p2p</a> <a href="/tags/代收/" style="font-size: 15px;">代收</a> <a href="/tags/央行/" style="font-size: 15px;">央行</a> <a href="/tags/证监会/" style="font-size: 15px;">证监会</a> <a href="/tags/私募基金/" style="font-size: 15px;">私募基金</a> <a href="/tags/PE/" style="font-size: 15px;">PE</a> <a href="/tags/委托贷款/" style="font-size: 15px;">委托贷款</a> <a href="/tags/私募/" style="font-size: 15px;">私募</a> <a href="/tags/jshell/" style="font-size: 15px;">jshell</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/http-2/" style="font-size: 15px;">http/2</a> <a href="/tags/fabric/" style="font-size: 15px;">fabric</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/说明文档/" style="font-size: 15px;">说明文档</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/10/05/金融/促进金融科技发展 支持上海建设金融科技中心/">金融/促进金融科技发展 支持上海建设金融科技中心</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/05/技术杂项/字符集和字符编码/">技术杂项/字符集和字符编码</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/13/说明/常用正则/">常用正则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/技术杂项/架构/架构在做什么1/">架构在做什么1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/金融/中国人民银行/中国人民银行关于规范代收业务的通知/">中国人民银行关于规范代收业务的通知 (征求意见稿)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/金融/中国人民银行/中国人民银行关于规范代收业务 的通知（征求意见稿）》主要问题说明/">《中国人民银行关于规范代收业务的通知（征求意见稿）》主要问题说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/找书途径及下载方法/">找书途径及下载方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/金融/促进金融科技发展支持上海建设金融科技中心/">促进金融科技发展 支持上海建设金融科技中心</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/技术杂项/spring/设置context-path不能被服务发现的问题/">设置context-path不能被服务发现的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/21/金融/关于办理非法放贷刑事案件若干问题的意见/">关于办理非法放贷刑事案件若干问题的意见</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//oneforce-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">oneforce blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = '//hm.baidu.com/hm.js?' + '718da94a7cf34af2eac95661ab1fc06f';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script>(function () {
  var bp = document.createElement('script');
  bp.src = '//push.zhanzhang.baidu.com/push.js';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>