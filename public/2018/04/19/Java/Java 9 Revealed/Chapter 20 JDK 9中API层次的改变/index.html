<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JDK 9中API层次的改变 | oneforce blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/mermaid/6.0.0/mermaid.min.css"><script src="//cdn.bootcss.com/mermaid/6.0.0/mermaid.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-113549521-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JDK 9中API层次的改变</h1><a id="logo" href="/.">oneforce blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JDK 9中API层次的改变</h1><div class="post-meta">Apr 19, 2018<span> | </span><span class="category"><a href="/categories/Java-9-Revealed/">Java 9 Revealed</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/04/19/Java/Java 9 Revealed/Chapter 20 JDK 9中API层次的改变/" href="/2018/04/19/Java/Java 9 Revealed/Chapter 20 JDK 9中API层次的改变/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-下划线成为关键字"><span class="toc-text">一. 下划线成为关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-改进使用try-with-resources块的语法"><span class="toc-text">二. 改进使用try-with-resources块的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-如何在匿名类中使用-lt-gt-操作符"><span class="toc-text">三. 如何在匿名类中使用&lt;&gt;操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-接口中使用私有方法"><span class="toc-text">四. 接口中使用私有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-私有方法上的-SafeVarargs注解"><span class="toc-text">五. 私有方法上的@SafeVarargs注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-丢弃子进程的输出"><span class="toc-text">六. 丢弃子进程的输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-StrictMath类中的新方法"><span class="toc-text">七. StrictMath类中的新方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-对ClassLoader类的更改"><span class="toc-text">八. 对ClassLoader类的更改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九-Optional类中的新方法"><span class="toc-text">九. Optional类中的新方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十-CompletableFuture中的新方法"><span class="toc-text">十. CompletableFuture中的新方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一-旋转等待提示（Spin-Wait-Hints）"><span class="toc-text">十一. 旋转等待提示（Spin-Wait Hints）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二-Time-API-增强"><span class="toc-text">十二. Time API 增强</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Clock类"><span class="toc-text">1. Clock类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Duration类"><span class="toc-text">2. Duration类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-将持续时间划分另一个持续时间"><span class="toc-text">1. 将持续时间划分另一个持续时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转换和检索部分持续时间"><span class="toc-text">转换和检索部分持续时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-截取持续时间"><span class="toc-text">3 截取持续时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ofInstant-工厂方法"><span class="toc-text">3. ofInstant() 工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-获取纪元秒"><span class="toc-text">4. 获取纪元秒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-LocalDate流"><span class="toc-text">5. LocalDate流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-新的格式化选项"><span class="toc-text">6. 新的格式化选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-修正儒略日格式"><span class="toc-text">1. 修正儒略日格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-通用时区名称"><span class="toc-text">2. 通用时区名称</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三-使用Scanner进行流操作"><span class="toc-text">十三. 使用Scanner进行流操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四-Matcher类的增强"><span class="toc-text">十四. Matcher类的增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十五-Object类的增强"><span class="toc-text">十五. Object类的增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十六-数组比较"><span class="toc-text">十六. 数组比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十七-Applet-API已经废弃"><span class="toc-text">十七. Applet API已经废弃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十八-Javadoc增强"><span class="toc-text">十八. Javadoc增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十九-本地桌面功能"><span class="toc-text">十九. 本地桌面功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二十-对象反序列化过滤器"><span class="toc-text">二十. 对象反序列化过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二十一-Java-I-O-API新增方法"><span class="toc-text">二十一. Java I/O API新增方法</span></a></li></ol></div></div><div class="post-content"><p><a href="http://www.cnblogs.com/IcanFixIt/p/7271461.html" target="_blank" rel="noopener">原文地址</a></p>
<p>在最后一章内容中，主要介绍以下内容：</p>
<ul>
<li>下划线作为新关键字</li>
<li>改进使用try-with-resources块的语法</li>
<li>如何在匿名类中使用&lt;&gt;操作符</li>
<li>如何在接口中使用私有方法</li>
<li>如何在私有方法上使用@SafeVarargs注解</li>
<li>如何丢弃子进程的输出</li>
<li>如何在Math和StrictMath类中使用新的方法</li>
<li>如何使用Optionals流以及Optionals上的新的操作</li>
<li>如何使用等待提示（spin-wait hints）</li>
<li>对Time API和Matcher和Objects类的增强</li>
<li>如何比较数组和数组的一部分</li>
<li>Javadoc的增强功能以及如何使用其新的搜索功能</li>
<li>本地桌面支持JDK 9以及如何使用它们</li>
<li>在对象反序列化过程中如何使用全局和局部过滤器</li>
<li>如何将数据从输入流传输到输出流以及如何复制和分片缓冲区</li>
</ul>
<p>Java SE 9有很多小的变化。大的变化包括引入了模块系统，HTTP/2Client API等。 本章涵盖了对Java开发人员重要的所有更改。 每个部分涵盖一个新的主题。 如果兴趣了解特定主题，可以直接跳转到该主题的部分。</p>
<p>示例的源代码在com.jdojo.misc模块中，其声明如下示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-info.java</span></span><br><span class="line"><span class="keyword">module</span> com.jdojo.misc &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.desktop;</span><br><span class="line">    <span class="keyword">exports</span> com.jdojo.misc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该模块读取了java.desktop模块，需要它来实现特定于平台的桌面功能。</p>
<h2 id="一-下划线成为关键字"><a href="#一-下划线成为关键字" class="headerlink" title="一. 下划线成为关键字"></a>一. 下划线成为关键字</h2><p>在JDK 9中，下划线（<code>_</code>）是一个关键字，不能将其本身用作单个字符标识符，例如变量名称，方法名称，类型名称等。但是，仍然可以使用下划线用在多个字符的标识符名称中。 考虑下面程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UnderscoreTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnderscoreTest</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use an underscore as an identifier. It is a compile-time warning in JDK 8 and a</span></span><br><span class="line">        <span class="comment">// compile-time error in JDK 9.</span></span><br><span class="line">        <span class="keyword">int</span> _ = <span class="number">19</span>;</span><br><span class="line">        System.out.println(_);</span><br><span class="line">        <span class="comment">// Use an underscore in multi-character identifiers. They are fine in JDK 8 and JDK 9.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> FINGER_COUNT = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">final</span> String _prefix = <span class="string">"Sha"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK 8中编译UnderscoreTest类会产生两个警告，用于使用下划线作为标识符，一个用于变量声明，一个用于<code>System.out.println()</code>方法调用。 每次使用下划线时都会产生警告。 JDK 8生成以下两个警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">com.jdojo.misc\src\com\jdojo\misc\UnderscoreTest.java:<span class="number">8</span>: warning: <span class="string">'_'</span> used as an identifier</span><br><span class="line">        <span class="keyword">int</span> _ = <span class="number">19</span>;</span><br><span class="line">            ^</span><br><span class="line">  (use of <span class="string">'_'</span> as an identifier might not be supported in releases after Java SE <span class="number">8</span>)</span><br><span class="line">com.jdojo.misc\src\com\jdojo\misc\UnderscoreTest.java:<span class="number">9</span>: warning: <span class="string">'_'</span> used as an identifier</span><br><span class="line">        System.out.println(_);</span><br><span class="line">                           ^</span><br><span class="line">  (use of <span class="string">'_'</span> as an identifier might not be supported in releases after Java SE <span class="number">8</span>)</span><br><span class="line"><span class="number">2</span> warnings</span><br><span class="line">Compiling the UnderscoreTest class in JDK 9 generates the following two compile-time errors:</span><br><span class="line">com.jdojo.misc\src\com\jdojo\misc\UnderscoreTest.java:<span class="number">8</span>: error: as of release <span class="number">9</span>, <span class="string">'_'</span> is a keyword, and may not be used as an identifier</span><br><span class="line">        <span class="keyword">int</span> _ = <span class="number">19</span>;</span><br><span class="line">            ^</span><br><span class="line">com.jdojo.misc\src\com\jdojo\misc\UnderscoreTest.java:<span class="number">9</span>: error: as of release <span class="number">9</span>, <span class="string">'_'</span> is a keyword, and may not be used as an identifier</span><br><span class="line">        System.out.println(_);</span><br><span class="line">                           ^</span><br><span class="line"><span class="number">2</span> errors</span><br></pre></td></tr></table></figure>
<p>JDK 9中的下划线的特殊含义是什么，在哪里使用它？ 在JDK 9中，被限制不将其用作标识符。 JDK设计人员打算在未来的JDK版本中给它一个特殊的含义。 所以，等到JDK 10或11，将它看作具有特殊含义的关键字。</p>
<h2 id="二-改进使用try-with-resources块的语法"><a href="#二-改进使用try-with-resources块的语法" class="headerlink" title="二. 改进使用try-with-resources块的语法"></a>二. 改进使用try-with-resources块的语法</h2><p>JDK 7向<code>java.lang</code>包添加了一个AutoCloseable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 7还添加了一个名为try-with-resources的新块，可用于使用以下步骤管理AutoCloseable对象（或资源）：</p>
<ul>
<li>将该资源的引用分配给块开头的新声明的变量。</li>
<li>使用块中的资源。</li>
<li>当块的主体被退出时，代表资源的变量的close()方法将被自动调用。</li>
</ul>
<p>这避免了在JDK 7之前使用finally块编写的样板代码。以下代码片段显示了开发人员如何管理可关闭的资源，假设存在实现AutoCloseable接口的Resource类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prior to JDK 7*/</span></span><br><span class="line">Resource res = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// Create the resource</span></span><br><span class="line">    res = <span class="keyword">new</span> Resource();</span><br><span class="line">    <span class="comment">// Work with res here</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(res != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 7中的try-with-resources块大大改善了这种情况。 在JDK 7中，可以重写以前的代码段，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = <span class="keyword">new</span> Resource()) &#123;</span><br><span class="line">    <span class="comment">// Work with res here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当控制退出try块时，这段代码将在res上调用close()方法。 可以在try块中指定多个资源，每个资源以分号分隔：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res1 = <span class="keyword">new</span> Resource(); Resource res2 = <span class="keyword">new</span> Resource()) &#123;</span><br><span class="line">     <span class="comment">// Work with res1 and res2 here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当try块退出时，两个资源res1和res2上的close()方法将被自动调用。 资源以相反的顺序关闭。 在这个例子中，将按顺序调用res2.close()和res1.close()。</p>
<p>JDK 7和8要求在try-with-resources块中声明引用资源的变量。 如果在方法中收到资源引用作为参数，那么无法编写如下所示的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void useIt(Resource res) &#123;</span><br><span class="line">    // A compile-time error in JDK 7 and 8</span><br><span class="line">    try(res) &#123;</span><br><span class="line">        // Work with res here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了规避此限制，必须声明另一个新的变量的Resource类型，并用参数值初始化它。 以下代码段显示了这种方法。 它声明一个新的参考变量res1，当try块退出时，将调用close()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void useIt(Resource res) &#123;        </span><br><span class="line">    try(Resource res1 = res) &#123;</span><br><span class="line">        // Work with res1 here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 9删除了该限制，必须使用try-with-resource块为要管理的资源声明新变量。 现在，可以使用try-with-resources块来管理final或有效的final变量来引用资源。 如果使用final关键字显式声明变量，则该变量为final。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// res is explicitly final</span></span><br><span class="line"><span class="keyword">final</span> Resource res = <span class="keyword">new</span> Resource();</span><br></pre></td></tr></table></figure>
<p>如果变量在初始化之后从未更改，则该变量实际上是final的。 在下面的代码片段中，尽管res变量未被声明为final，但是res变量是有效的。 它被初始化，从不再次更改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// res is effectively final</span></span><br><span class="line">    Resource res = <span class="keyword">new</span> Resource();</span><br><span class="line">    res.useMe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK 9中，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Resource res = <span class="keyword">new</span> Resource();</span><br><span class="line"><span class="keyword">try</span> (res) &#123;</span><br><span class="line">    <span class="comment">// Work with res here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个资源要使用try-with-resources块来管理，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Resource res1 = <span class="keyword">new</span> Resource();</span><br><span class="line">Resource res2 = <span class="keyword">new</span> Resource();</span><br><span class="line"><span class="keyword">try</span> (res1; res2) &#123;</span><br><span class="line">    <span class="comment">// Use res1 and res2 here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将JDK 8和JDK 9方法混合在同一个资源块中。 以下代码片段在try-with-resources块中使用两个预先声明的有效的final变量和一个新声明的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Resource res1 = <span class="keyword">new</span> Resource();</span><br><span class="line">Resource res2 = <span class="keyword">new</span> Resource();</span><br><span class="line"><span class="keyword">try</span> (res1; res2; Resource res3 = <span class="keyword">new</span> Resource()) &#123;</span><br><span class="line">    <span class="comment">// Use res1, res2, and res3 here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在JDK 7中，在资源块中声明的变量是隐含的final的。 以下代码片段明确声明了这样一个final变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Resource res1 = new Resource();</span><br><span class="line">Resource res2 = new Resource();</span><br><span class="line">// Declare res3 explicitly final</span><br><span class="line">try (res1; res2; final Resource res3 = new Resource()) &#123;</span><br><span class="line">    // Use res1, res2, and res3 here            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一个完整的例子。 JDK中有几个类是AutoCloseable，例如java.io包中的InputStream和OutputStream类。 下面包含实现AutoCloseable接口的Resource类的代码。 Resource类的对象可以作为由try-with-resources管理的资源。 id实例变量用于跟踪资源。 构造方法和其他方法在调用时简单地打印消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resource.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resource</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.id = id;                </span><br><span class="line">        System.out.printf(<span class="string">"Created resource %d.%n"</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useIt</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        System.out.printf(<span class="string">"Using resource %d.%n"</span>, <span class="keyword">this</span>.id);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Closing resource %d.%n"</span>, <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面包含了ResourceTest类的代码，它显示了如何使用JDK 9的新功能，该功能允许使用final或有效的final变量来引用这些资源，并使用try-with-resources块来管理资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourceTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Resource r1 = <span class="keyword">new</span> Resource(<span class="number">1</span>);</span><br><span class="line">         Resource r2 = <span class="keyword">new</span> Resource(<span class="number">2</span>);</span><br><span class="line">         <span class="keyword">try</span>(r1; r2) &#123;</span><br><span class="line">             r1.useIt();</span><br><span class="line">             r2.useIt();</span><br><span class="line">             r2.useIt();</span><br><span class="line">         &#125;</span><br><span class="line">         useResource(<span class="keyword">new</span> Resource(<span class="number">3</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useResource</span><span class="params">(Resource res)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span>(res; Resource res4 = <span class="keyword">new</span> Resource(<span class="number">4</span>)) &#123;</span><br><span class="line">             res.useIt();</span><br><span class="line">             res4.useIt();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Created resource 1.</span><br><span class="line">Created resource 2.</span><br><span class="line">Using resource 1.</span><br><span class="line">Using resource 2.</span><br><span class="line">Using resource 2.</span><br><span class="line">Closing resource 2.</span><br><span class="line">Closing resource 1.</span><br><span class="line">Created resource 3.</span><br><span class="line">Created resource 4.</span><br><span class="line">Using resource 3.</span><br><span class="line">Using resource 4.</span><br><span class="line">Closing resource 4.</span><br><span class="line">Closing resource 3.</span><br></pre></td></tr></table></figure>
<h2 id="三-如何在匿名类中使用-lt-gt-操作符"><a href="#三-如何在匿名类中使用-lt-gt-操作符" class="headerlink" title="三. 如何在匿名类中使用&lt;&gt;操作符"></a>三. 如何在匿名类中使用&lt;&gt;操作符</h2><p>JDK 7引入了一个钻石操作符（<code>&lt;&gt;</code>），用于调用泛型类的构造方法，只要编译器可以推断通用类型即可。 以下两个语句是一样的；第二个使用钻石操作符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Specify the generic type explicitly</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// The compiler infers ArrayList&lt;&gt; as ArrayList&lt;String&gt;</span></span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>创建匿名类时，JDK 7不允许使用钻石操作符。 以下代码片段使用带有钻石操作符的匿名类来创建Callable<v>接口的实例：</v></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// A compile-time error in JDK 7 and 8</span><br><span class="line">Callable&lt;Integer&gt; c = new Callable&lt;&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() &#123;</span><br><span class="line">        return 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面语句在JDK 7和8中生成以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error: cannot infer type arguments for Callable&lt;V&gt;</span><br><span class="line">        Callable&lt;Integer&gt; c = new Callable&lt;&gt;() &#123;</span><br><span class="line">                                          ^</span><br><span class="line">  reason: cannot use &apos;&lt;&gt;&apos; with anonymous inner classes</span><br><span class="line">  where V is a type-variable:</span><br><span class="line">    V extends Object declared in interface Callable</span><br><span class="line">1 error</span><br></pre></td></tr></table></figure>
<p>可以通过指定通用类型代替钻石运算符来解决此错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Works in JDK 7 and 8</span><br><span class="line">Callable&lt;Integer&gt; c = new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() &#123;</span><br><span class="line">        return 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JDK 9就添加了对匿名类中的钻石操作符的支持，只要推断的类型是可表示的。 不能使用具有匿名类的钻石操作符 —— 即使在JDK 9中，如果推断的类型是不可表示的。 Java编译器使用许多不能用Java程序编写的类型。 可以用Java程序编写的类型称为可表示类型。 编译器知道但不能用Java程序编写的类型称为非可表示类型。 例如，String是一个可表示类型，因为可以在程序中使用它来表示类型；然而，Serializable＆CharSequence不是一个可表示类型的，即使它是编译器的有效类型。 它是一种交叉类型，表示实现两个接口Serializable和CharSequence的类型。 通用类型定义允许使用交集类型，但不能使用此交集类型声明变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Not allowed in Java code. Cannot declare a variable of an intersection type.</span><br><span class="line">Serializable &amp; CharSequence var;</span><br><span class="line">// Allowed in Java code</span><br><span class="line">class Magic&lt;T extends Serializable &amp; CharSequence&gt; &#123;        </span><br><span class="line">    // More code goes here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK 9中，以下是允许使用具有匿名类的钻石操作符的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A compile-time error in JDK 7 and 8, but allowed in JDK 9.</span></span><br><span class="line">Callable&lt;Integer&gt; c = <span class="keyword">new</span> Callable&lt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用Magic类的这个定义，JDK 9允许使用像这样的匿名类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allowed in JDK 9. The &lt;&gt; is inferred as &lt;String&gt;.</span></span><br><span class="line">Magic&lt;String&gt; m1 = <span class="keyword">new</span> Magic&lt;&gt;()&#123;</span><br><span class="line">    <span class="comment">// More code goes here</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下使用Magic类不会在JDK 9中进行编译，因为编译器将通用类型推断为不可表示类型的交集类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A compile-time error in JDK 9. The &lt;&gt; is inferred as &lt;Serializable &amp; CharSequence&gt;,</span></span><br><span class="line"><span class="comment">// which is non-denotable</span></span><br><span class="line">Magic&lt;?&gt; m2 = <span class="keyword">new</span> Magic&lt;&gt;()&#123;</span><br><span class="line">    <span class="comment">// More code goes here</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码生成以下编译时错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error: cannot infer type arguments for Magic&lt;&gt;</span><br><span class="line">        Magic&lt;?&gt; m2 = new Magic&lt;&gt;()&#123;</span><br><span class="line">                               ^</span><br><span class="line">  reason: type argument INT#1 inferred for Magic&lt;&gt; is not allowed in this context</span><br><span class="line">    inferred argument is not expressible in the Signature attribute</span><br><span class="line">  where INT#1 is an intersection type:</span><br><span class="line">    INT#1 extends Object,Serializable,CharSequence</span><br><span class="line">1 error</span><br></pre></td></tr></table></figure>
<h2 id="四-接口中使用私有方法"><a href="#四-接口中使用私有方法" class="headerlink" title="四. 接口中使用私有方法"></a>四. 接口中使用私有方法</h2><p>JDK 8在接口中引入了静态和默认的方法。 如果必须在这些方法中多次执行相同的逻辑，则只能重复逻辑或将逻辑移动到另一个类来隐藏实现。 考虑名为Alphabet的接口，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alphabet.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Alphabet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAtOddPos</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Character.isLetter(c)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not a letter: "</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> uc = Character.toUpperCase(c);</span><br><span class="line">        <span class="keyword">int</span> pos = uc - <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">return</span> pos % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAtEvenPos</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Character.isLetter(c)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not a letter: "</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> uc = Character.toUpperCase(c);</span><br><span class="line">        <span class="keyword">int</span> pos = uc - <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">return</span> pos % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isAtOddpos()</code>和<code>isAtEvenPos()</code>方法检查指定的字符是否为奇数或偶数字母顺序，假设我们只处理英文字母。逻辑假定A和a位于位置1，B和b位于位置2等。请注意，两种方法中的逻辑仅在返回语句中有所不同。这些方法的整体是相同的，除了最后的语句。你会同意需要重构这个逻辑。将常用逻辑转移到另一种方法，并从两种方法调用新方法将是理想的情况。但是，不希望在JDK 8中执行此操作，因为接口仅支持公共方法。这样做会使第三种方式公开，这将暴露给你不想做的外部世界。</p>
<p>JDK 9允许在接口中声明私有方法。下显示了使用包含两种方法使用的通用逻辑的专用方法的Alphabet接口的重构版本。这一次，命名了接口AlphabetJdk9，以确保可以在源代码中包含这两个版本。现有的两种方法成为一行代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlphabetJdk9.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AlphabetJdk9</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAtOddPos</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPos(c) % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAtEvenPos</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPos(c) % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPos</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Character.isLetter(c)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not a letter: "</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> uc = Character.toUpperCase(c);</span><br><span class="line">        <span class="keyword">int</span> pos = uc - <span class="number">64</span>;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK 9之前，接口中的所有方法都被隐式公开。 记住这些适用于Java中所有程序的简单规则：</p>
<ul>
<li>private方法不能被继承，因此不能被重写。</li>
<li>final方法不能被重写。</li>
<li>abstract方法是可以继承的，意图是被重写。</li>
<li>default方法是一个实例方法，并提供默认实现。 这意味着可以被重写。</li>
</ul>
<p>通过在JDK 9中引入私有方法，需要在接口声明方法时遵循一些规则。 修饰符的所有组合——abstract，public，private，static。 下表列出了在JDK 9中的接口的方法声明中支持和不支持的修饰符的组合。请注意，接口的方法声明中不允许使用fjinal修饰符。 根据这个列表，可以在一个非抽象，非默认的实例方法或一个静态方法的接口中有一个私有方法。</p>
<table>
<thead>
<tr>
<th>Modifiers</th>
<th>Supported?</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static</td>
<td>Yes</td>
<td>从JDK 8开始支持</td>
</tr>
<tr>
<td>public abstract</td>
<td>Yes</td>
<td>从JDK 1开始支持</td>
</tr>
<tr>
<td>public default</td>
<td>Yes</td>
<td>从JDK 8开始支持</td>
</tr>
<tr>
<td>private static</td>
<td>Yes</td>
<td>从JDK 9开始支持</td>
</tr>
<tr>
<td>private</td>
<td>Yes</td>
<td>从JDK 9开始支持，这是一个非抽象的实例方法</td>
</tr>
<tr>
<td>private abstract</td>
<td>No</td>
<td>这种组合没有意义</td>
</tr>
<tr>
<td>private default</td>
<td>No</td>
<td>这种组合没有意义，私有方法不被继承，因此不能被重写，而如果需要，默认方法的本意是需要重写的。</td>
</tr>
</tbody>
</table>
<h2 id="五-私有方法上的-SafeVarargs注解"><a href="#五-私有方法上的-SafeVarargs注解" class="headerlink" title="五. 私有方法上的@SafeVarargs注解"></a>五. 私有方法上的@SafeVarargs注解</h2><p>具体化类型表示其信息在运行时完全可用，例如String，Integer，List等。非具体化类型表示其信息已由编译器使用类型擦除（例如List<string>）删除， 编译后成为List。</string></p>
<p>当使用非具体化类型的可变（var-args）参数时，该参数的类型仅供编译器使用。 编译器将擦除参数化类型，并将其替换为无界类型的实际类型为Object []的数组，其类型为有界类型的上限的特定数组。 编译器不能保证对方法体内的这种非具体化可变参数执行的操作是安全的。 考虑以下方法的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; void print(T... args) &#123;</span><br><span class="line">    for(T element : args) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器将用<code>print(Object[] args)</code>替换<code>print(T… args)</code>。 该方法的主体对args参数不执行任何不安全的操作。考虑执行以下不安全操作的方法声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void unsafe(List&lt;Long&gt;... rolls) &#123;</span><br><span class="line">    Object[] list = rolls;        </span><br><span class="line">    list[0] = List.of(&quot;One&quot;, &quot;Two&quot;);</span><br><span class="line">    // Unsafe!!! Will throw a ClassCastException at runtime</span><br><span class="line">    Long roll = rolls[0].get(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unsafe()方法将rolls（它是List<string>的数组）分配给一个Object []数组。 它将List<string>存储到Object []的第一个元素中，这也是允许的。 rolls [0]的类型被推断为List <long>，get(0)方法应该返回一个Long。 但是，运行时会抛出一个ClassCastException，因为rolls[0].get(0)返回的实际类型是String，而不是Long。</long></string></string></p>
<p>当声明使用非具体化的可变参数类型的print()和unsafe()方法时，Java编译器会发出如下所示的未经检查的警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: [unchecked] Possible heap pollution from parameterized vararg type List&lt;Long&gt;</span><br><span class="line">    public static void unsafe(List&lt;Long&gt;... rolls) &#123;</span><br></pre></td></tr></table></figure>
<pre><code>^
</code></pre><p>编译器会为此类方法声明生成警告，并为每次调用该方法发出警告。 如果unsafe()方法被调用五次，将收到六个警告（一个用于声明，五个调用）。 可以在方法声明和调用站点上使用<code>@SafeVarargs</code>注解来抑制这些警告。 通过将此注解添加到方法声明中，确保方法的用户和编译器在方法的主体中，不对非具体化的可变参数类型执行任何不安全的操作。 你的保证是足够好的，编译器不发出警告。 但是，如果你的保证在运行时证明是不真实的，则运行时将抛出适当类型的异常。</p>
<p>在JDK 9之前，可以在以下可执行的（构造函数和方法）上使用<code>@SafeVarargs</code>注解：</p>
<ul>
<li>构造方法</li>
<li>static方法</li>
<li>final方法</li>
</ul>
<p>构造方法，static方法和final方法是不可重写的。 允许<code>@SafeVarargs</code>注解仅适用于不可重写的可执行的代码的想法，是为了保护开发人员在重写可执行代码上违反注解约束的重写可执行文件上使用此注解。 假设有一个类X，它包含一个方法m1()，它包含一个<code>@SafeVarargs</code>。 进一步假设有一个从类X继承的类Y。类Y可以重写继承的方法m1()，并可能有不安全的操作。 这将产生运行时惊喜，因为开发人员可以根据父类X编写代码，并且可能不会期望任何不安全的操作，如其方法m1()所承诺的。</p>
<p>私有方法也是不可重写的，所以JDK 9决定在私有方法上允许<code>@SafeVarargs</code>注解。 下面显示了一个使用@SafeVarargs注解的私有方法的类。 在JDK 9中可以具有<code>@SafeVarargs</code>注释的可执行列表如下所示：</p>
<ul>
<li>构造方法</li>
<li>static方法</li>
<li>final方法</li>
<li>私有方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SafeVarargsTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeVarargsTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Allowed in JDK 9</span></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(T element : args) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// More code goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK 8中编译此类会生成以下错误，它指出<code>@SafeVarargs</code>不能在非final方法中使用，这是一种私有方法。 需要使用<code>-Xlint:unchecked</code>选项编译源代码以查看错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com\jdojo\misc\SafeVarargsTest.java:6: error: Invalid SafeVarargs annotation. Instance method &lt;T&gt; print(T...) is not final.</span><br><span class="line">    private &lt;T&gt; void print(T... args) &#123;</span><br><span class="line">                     ^</span><br><span class="line">  where T is a type-variable:</span><br><span class="line">    T extends Object declared in method &lt;T&gt;print(T...)</span><br></pre></td></tr></table></figure>
<h2 id="六-丢弃子进程的输出"><a href="#六-丢弃子进程的输出" class="headerlink" title="六. 丢弃子进程的输出"></a>六. 丢弃子进程的输出</h2><p>JDK 9向<code>ProcessBuilder.Redirect</code>嵌套类添加了一个<code>DISCARD</code>新常量。 它的类型是<code>ProcessBuilder.Redirect</code>。 当要丢弃输出时，可以将其用作子进程的输出和错误流的目标。 实现通过写入操作系统特定的“空文件（null file）”来丢弃输出。下面包含一个完整的程序，显示如何丢弃子进程的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DiscardProcessOutput.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardProcessOutput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Using Redirect.INHERIT:"</span>);</span><br><span class="line">        startProcess(ProcessBuilder.Redirect.INHERIT);</span><br><span class="line">        System.out.println(<span class="string">"\nUsing Redirect.DISCARD:"</span>);</span><br><span class="line">        startProcess(ProcessBuilder.Redirect.DISCARD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startProcess</span><span class="params">(ProcessBuilder.Redirect outputDest)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder()</span><br><span class="line">                    .command(<span class="string">"java"</span>, <span class="string">"-version"</span>)                    </span><br><span class="line">                    .redirectOutput(outputDest)</span><br><span class="line">                    .redirectError(outputDest);</span><br><span class="line">            Process process = pb.start();</span><br><span class="line">            process.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Using Redirect.INHERIT:</span><br><span class="line">java version &quot;9-ea&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 9-ea+157)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 9-ea+157, mixed mode)</span><br><span class="line">Using Redirect.DISCARD:</span><br><span class="line">Listing 20-8.</span><br><span class="line">Discarding a Process’ Outputs</span><br></pre></td></tr></table></figure>
<p><code>startProcess()</code>方法通过使用-version参数启动java程序来开始一个进程。 该方法通过输出目的地参数。 第一次，<code>Redirect.INHERIT</code>作为输出目的地传递，这允许子进程使用标准输出和标准错误来打印消息。 第二次，<code>Redirect.DISCARD</code>作为输出目标传递，没有子进程的输出。</p>
<h2 id="七-StrictMath类中的新方法"><a href="#七-StrictMath类中的新方法" class="headerlink" title="七. StrictMath类中的新方法"></a>七. StrictMath类中的新方法</h2><p>JDK在java.lang包中包含两个类<code>Math</code>和<code>StrictMath</code>。 这两个类只包含静态成员，它们包含提供基本数字操作（如平方根，绝对值，符号，三角函数和双曲线函数）的方法。 为什么有两个类来提供类似的操作？ Math类不需要在所有实现中返回相同的结果。 这允许它使用库的本地实现来进行操作，这可能会在不同的平台上返回稍微不同的结果。StrictMath类必须在所有实现中返回相同的结果。 Math类中的许多方法都调用StrictMath类的方法。 JDK 9将以下静态方法添加到Math和StrictMath类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">floorDiv</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floorMod</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fma</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z)</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">fma</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">multiplyExact</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">multiplyFull</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">multiplyHigh</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span></span></span><br></pre></td></tr></table></figure>
<p><code>floorDiv()`</code>方法返回小于或等于将x除以y的代数商的最大长度值。 当两个参数具有相同的符号时，除法结果将向零舍入（截断模式）。 当它们具有不同的符号时，除法结果将朝向负无穷大。 当被除数为Long.MIN_VALUE而除数为-1时，该方法返回Long.MIN_VALUE。 当除数为零时抛出ArithmeticException。</p>
<p><code>floorMod()</code>方法返回最小的模数，等于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x - (floorDiv(x, y) * y)</span><br></pre></td></tr></table></figure>
<p>最小模数的符号与除数y相同，在<code>-abs(y) &lt; r &lt; +abs(y)</code>范围内。</p>
<p>fma()方法对应于IEEE 754-2008中定义的<code>fusedMultiplyAdd</code>操作。 它返回<code>(a * b + c)</code>的结果，如同无限范围和精度一样，并舍入一次到最接近的double或float值。 舍入是使用到最近的偶数舍入模式完成的。 请注意，<code>fma()</code>方法返回比表达式<code>(a * b + c)</code>更准确的结果，因为后者涉及两个舍入误差——一个用于乘法，另一个用于加法，而前者仅涉及一个舍入误差。</p>
<p><code>multiplyExact()</code>方法返回两个参数的乘积，如果结果超过long类型最大能表示的数字，则抛出ArithmeticException异常。</p>
<p><code>multiplyFull()</code>方法返回两个参数的确切乘积。</p>
<p><code>multiplyHigh()</code>方法返回长度是两个64位参数的128位乘积的最高有效64位。 当乘以两个64位长的值时，结果可能是128位值。 因此，该方法返回significant (high)64位。 下面包含一个完整的程序，用于说明在StrictMath类中使用这些新方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StrictMathTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.StrictMath.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrictMathTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Using StrictMath.floorDiv(long, int):"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"floorDiv(20L, 3) = %d%n"</span>, floorDiv(<span class="number">20L</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.printf(<span class="string">"floorDiv(-20L, -3) = %d%n"</span>, floorDiv(-<span class="number">20L</span>, -<span class="number">3</span>));</span><br><span class="line">        System.out.printf(<span class="string">"floorDiv(-20L, 3) = %d%n"</span>, floorDiv(-<span class="number">20L</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.printf(<span class="string">"floorDiv(Long.Min_VALUE, -1) = %d%n"</span>, floorDiv(Long.MIN_VALUE, -<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"\nUsing StrictMath.floorMod(long, int):"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"floorMod(20L, 3) = %d%n"</span>, floorMod(<span class="number">20L</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.printf(<span class="string">"floorMod(-20L, -3) = %d%n"</span>, floorMod(-<span class="number">20L</span>, -<span class="number">3</span>));</span><br><span class="line">        System.out.printf(<span class="string">"floorMod(-20L, 3) = %d%n"</span>, floorMod(-<span class="number">20L</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"\nUsing StrictMath.fma(double, double, double):"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"fma(3.337, 6.397, 2.789) = %f%n"</span>, fma(<span class="number">3.337</span>, <span class="number">6.397</span>, <span class="number">2.789</span>));</span><br><span class="line">        System.out.println(<span class="string">"\nUsing StrictMath.multiplyExact(long, int):"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"multiplyExact(29087L, 7897979) = %d%n"</span>,</span><br><span class="line">                multiplyExact(<span class="number">29087L</span>, <span class="number">7897979</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"multiplyExact(Long.MAX_VALUE, 5) = %d%n"</span>,</span><br><span class="line">                    multiplyExact(Long.MAX_VALUE, <span class="number">5</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"multiplyExact(Long.MAX_VALUE, 5) = "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\nUsing StrictMath.multiplyFull(int, int):"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"multiplyFull(29087, 7897979) = %d%n"</span>, multiplyFull(<span class="number">29087</span>, <span class="number">7897979</span>));</span><br><span class="line">        System.out.println(<span class="string">"\nUsing StrictMath.multiplyHigh(long, long):"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"multiplyHigh(29087L, 7897979L) = %d%n"</span>,</span><br><span class="line">                multiplyHigh(<span class="number">29087L</span>, <span class="number">7897979L</span>));</span><br><span class="line">        System.out.printf(<span class="string">"multiplyHigh(Long.MAX_VALUE, 8) = %d%n"</span>,</span><br><span class="line">                multiplyHigh(Long.MAX_VALUE, <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Using StrictMath.floorDiv(long, int):</span><br><span class="line">floorDiv(20L, 3) = 6</span><br><span class="line">floorDiv(-20L, -3) = 6</span><br><span class="line">floorDiv(-20L, 3) = -7</span><br><span class="line">floorDiv(Long.Min_VALUE, -1) = -9223372036854775808</span><br><span class="line">Using StrictMath.floorMod(long, int):</span><br><span class="line">floorMod(20L, 3) = 2</span><br><span class="line">floorMod(-20L, -3) = -2</span><br><span class="line">floorMod(-20L, 3) = 1</span><br><span class="line">Using StrictMath.fma(double, double, double):</span><br><span class="line">fma(3.337, 6.397, 2.789) = 24.135789</span><br><span class="line">Using StrictMath.multiplyExact(long, int):</span><br><span class="line">multiplyExact(29087L, 7897979) = 229728515173</span><br><span class="line">multiplyExact(Long.MAX_VALUE, 5) = long overflow</span><br><span class="line">Using StrictMath.multiplyFull(int, int):</span><br><span class="line">multiplyFull(29087, 7897979) = 229728515173</span><br><span class="line">Using StrictMath.multiplyHigh(long, long):</span><br><span class="line">multiplyHigh(29087L, 7897979L) = 0</span><br><span class="line">multiplyHigh(Long.MAX_VALUE, 8) = 3</span><br></pre></td></tr></table></figure>
<h2 id="八-对ClassLoader类的更改"><a href="#八-对ClassLoader类的更改" class="headerlink" title="八. 对ClassLoader类的更改"></a>八. 对ClassLoader类的更改</h2><p>JDK 9将以下构造方法和方法添加到<code>java.lang.ClassLoader</code>类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Class&lt;?&gt; <span class="title">findClass</span><span class="params">(String moduleName, String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String moduleName, String name)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Stream&lt;URL&gt; <span class="title">resources</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isRegisteredAsParallelCapable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Module <span class="title">getUnnamedModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getPlatformClassLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Package <span class="title">getDefinedPackage</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Package[] <span class="title">getDefinedPackages</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这些方法具有直观的名称。受保护的构造方法和方法适用于开发人员创建新的类加载器。</p>
<p>一个类加载器可以有一个可选的名称，可以使用<code>getName()</code>方法。 当类加载器没有名称时，该方法返回null。 Java运行时将包括堆栈跟踪和异常消息中的类加载程序名称（如果存在）。 这将有助于调试。</p>
<p><code>resources()</code>方法返回使用特定资源名称找到的所有资源的URL流。</p>
<p>每个类加载器都包含一个未命名的模块，该模块包含该类加载器从类路径加载的所有类型。 <code>getUnnamedModule()</code>方法返回类加载器的未命名模块的引用。</p>
<p>静态<code>getPlatformClassLoader()</code>方法返回平台类加载器的引用。</p>
<h2 id="九-Optional类中的新方法"><a href="#九-Optional类中的新方法" class="headerlink" title="九. Optional类中的新方法"></a>九. Optional<t>类中的新方法</t></h2><p>JDK 9中的java.util.Optional<t>类已经添加了三种新方法：</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifPresentOrElse</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Runnable emptyAction)</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">or</span><span class="params">(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</span></span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在描述这些方法并提供一个显示其使用的完整程序之前，请考虑以下Optional<integer>列表：</integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Optional&lt;Integer&gt;&gt; optionalList = List.of(Optional.of(<span class="number">1</span>),</span><br><span class="line">                                               Optional.empty(),</span><br><span class="line">                                               Optional.of(<span class="number">2</span>),</span><br><span class="line">                                               Optional.empty(),</span><br><span class="line">                                               Optional.of(<span class="number">3</span>));                                               </span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line">该列表包含五个元素，其中两个为空的Optional，三个包含值为<span class="number">1</span>，<span class="number">2</span>和<span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">`ifPresentOrElse()`方法可以提供两个备选的操作。 如果存在值，则使用该值执行指定的操作。 否则，它执行指定的可选值。 以下代码片段使用流打印列表中的所有元素，如果Optional不为空，则打印其具体的值，为空的话，替换为“Empty”字符串。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">optionalList.stream()</span><br><span class="line">            .forEach(p -&gt; p.ifPresentOrElse(System.out::println,</span><br><span class="line">                                            () -&gt; System.out.println(<span class="string">"Empty"</span>)));</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">Empty</span><br><span class="line">2</span><br><span class="line">Empty</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><code>or()</code>方法如果Optional有值则返回Optional本身。否则，返回指定supplier的Optional。以下代码从Optional列表中返回一个流，并使用or()方法映射空的Optionals为带有默认值0的Optionals.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">optionalList.stream()</span><br><span class="line">            .map(p -&gt; p.or(() -&gt; Optional.of(<span class="number">0</span>)))</span><br><span class="line">            .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional[1]</span><br><span class="line">Optional[0]</span><br><span class="line">Optional[2]</span><br><span class="line">Optional[0]</span><br><span class="line">Optional[3]</span><br></pre></td></tr></table></figure>
<p><code>stream()`</code>方法返回包含Optional中存在的值的元素的顺序流。 如果Optional为空，则返回一个空的流。 假设有一个Optional的列表，并且想收集另一个列表中的所有存在的值。 可以在Java 8中如下实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list8 will contain 1, 2, and 3</span></span><br><span class="line">List&lt;Integer&gt; list8 = optionalList.stream()</span><br><span class="line">                                  .filter(Optional::isPresent)</span><br><span class="line">                                  .map(Optional::get)</span><br><span class="line">                                  .collect(toList());</span><br></pre></td></tr></table></figure>
<p>必须使用过滤器过滤掉所有空的Optionals，并将剩余的可选项映射到其值。 使用JDK 9中的新的stream()方法，可以将filter()和map()操作组合成一个flatMap()操作，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list9 contain 1, 2, and 3</span></span><br><span class="line">List&lt;Integer&gt; list9 = optionalList.stream()</span><br><span class="line">                                  .flatMap(Optional::stream)</span><br><span class="line">                                  .collect(toList());</span><br></pre></td></tr></table></figure>
<p>下面包含一个完整的程序来演示使用这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OptionalTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a list of Optional&lt;Integer&gt;</span></span><br><span class="line">        List&lt;Optional&lt;Integer&gt;&gt; optionalList = List.of(</span><br><span class="line">                Optional.of(<span class="number">1</span>),</span><br><span class="line">                Optional.empty(),</span><br><span class="line">                Optional.of(<span class="number">2</span>),</span><br><span class="line">                Optional.empty(),</span><br><span class="line">                Optional.of(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">// Print the original list</span></span><br><span class="line">        System.out.println(<span class="string">"Original List: "</span> + optionalList);</span><br><span class="line">        <span class="comment">// Using the ifPresentOrElse() method</span></span><br><span class="line">        optionalList.stream()</span><br><span class="line">                    .forEach(p -&gt; p.ifPresentOrElse(System.out::println,</span><br><span class="line">                                                    () -&gt; System.out.println(<span class="string">"Empty"</span>)));</span><br><span class="line">        <span class="comment">// Using the or() method</span></span><br><span class="line">        optionalList.stream()</span><br><span class="line">                    .map(p -&gt; p.or(() -&gt; Optional.of(<span class="number">0</span>)))</span><br><span class="line">                    .forEach(System.out::println);</span><br><span class="line">        <span class="comment">// In Java 8</span></span><br><span class="line">        List&lt;Integer&gt; list8 = optionalList.stream()</span><br><span class="line">                                          .filter(Optional::isPresent)</span><br><span class="line">                                          .map(Optional::get)</span><br><span class="line">                                          .collect(toList());</span><br><span class="line">        System.out.println(<span class="string">"List in Java 8: "</span> + list8);</span><br><span class="line">        <span class="comment">// In Java 9</span></span><br><span class="line">        List&lt;Integer&gt; list9 = optionalList.stream()</span><br><span class="line">                                          .flatMap(Optional::stream)</span><br><span class="line">                                          .collect(toList());</span><br><span class="line">        System.out.println(<span class="string">"List in Java 9: "</span> + list9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Original List: [Optional[1], Optional.empty, Optional[2], Optional.empty, Optional[3]]</span><br><span class="line">1</span><br><span class="line">Empty</span><br><span class="line">2</span><br><span class="line">Empty</span><br><span class="line">3</span><br><span class="line">Optional[1]</span><br><span class="line">Optional[0]</span><br><span class="line">Optional[2]</span><br><span class="line">Optional[0]</span><br><span class="line">Optional[3]</span><br><span class="line">List in Java 8: [1, 2, 3]</span><br><span class="line">List in Java 9: [1, 2, 3]</span><br></pre></td></tr></table></figure>
<h2 id="十-CompletableFuture中的新方法"><a href="#十-CompletableFuture中的新方法" class="headerlink" title="十. CompletableFuture中的新方法"></a>十. CompletableFuture<t>中的新方法</t></h2><p>在JDK 9 中，<code>java.util.concurrent</code>包中的<code>CompletableFuture&lt;T&gt;`</code>类添加了以下新方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">newIncompleteFuture</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Executor <span class="title">defaultExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">copy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">CompletionStage&lt;T&gt; <span class="title">minimalCompletionStage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">completeAsync</span><span class="params">(Supplier&lt;? extends T&gt; supplier, Executor executor)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">completeAsync</span><span class="params">(Supplier&lt;? extends T&gt; supplier)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">orTimeout</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">CompletableFuture&lt;T&gt; <span class="title">completeOnTimeout</span><span class="params">(T value, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Executor <span class="title">delayedExecutor</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Executor <span class="title">delayedExecutor</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title">completedStage</span><span class="params">(U value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">failedFuture</span><span class="params">(Throwable ex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title">failedStage</span><span class="params">(Throwable ex)</span></span></span><br></pre></td></tr></table></figure>
<p>有关这些方法的更多信息，请查阅类的Javadoc。</p>
<h2 id="十一-旋转等待提示（Spin-Wait-Hints）"><a href="#十一-旋转等待提示（Spin-Wait-Hints）" class="headerlink" title="十一. 旋转等待提示（Spin-Wait Hints）"></a>十一. 旋转等待提示（Spin-Wait Hints）</h2><p>在多线程程序中，线程通常需要协调。一个线程可能必须等待另一个线程来更新volatile变量。 当volatile变量以某个值更新时，第一个线程可以继续。 如果等待可能更长，建议第一个线程通过睡眠或等待来放弃CPU，并且可以在恢复工作时通知它。 然而，使线程睡眠或等待具有延迟。 为了短时间等待并减少延迟，线程通常通过检查某个条件为真来循环等待。 考虑使用循环等待为dataReady的volatile变量等于true的类中代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> dataReady;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Wait until data is ready</span></span><br><span class="line">    <span class="keyword">while</span> (!dataReady) &#123;</span><br><span class="line">        <span class="comment">// No code</span></span><br><span class="line">    &#125;</span><br><span class="line">    processData();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Data processing logic goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码中的while循环称为<code>spin-loop</code>，<code>busy-spin</code>，<code>busy-wait</code>或<code>spin-wait</code>。 while保持循环，直到dataReady变量为true。<br>由于不必要的资源使用而不耐心等待，因此通常是需要的。 在这个例子中，优点是一旦dataReady变量变为true，线程就会开始处理数据。 然而，牺牲性能和功耗，因为线程正在活跃地循环。</p>
<p>某些处理器可以暗示线程处于旋转等待状态，如果可能，可以优化资源使用。 例如，x86处理器支持一个PAUSE指令来指示一个旋转等待。 该指令延迟下一条指令对线程的执行有限的少量时间，从而提高了资源的使用。</p>
<p>JDK 9向Thread类添加了一个新的静态onSpinWait()方法。 对处理器来说，这是一个纯粹的提示，即调用者线程暂时无法继续，因此可以优化资源使用。 当底层平台不支持这种提示时，此方法的可能实现可能是无效的。</p>
<p>下面包含示例代码。 请注意，程序的语义不会通过使用旋转等待提示来更改。 如果底层硬件支持提示，它可能会更好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpinWaitTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinWaitTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> dataReady = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Wait while data is ready</span></span><br><span class="line">        <span class="keyword">while</span> (!dataReady) &#123;</span><br><span class="line">            <span class="comment">// Hint a spin-wait</span></span><br><span class="line">            Thread.onSpinWait();</span><br><span class="line">        &#125;</span><br><span class="line">        processData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Data processing logic goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataReady</span><span class="params">(<span class="keyword">boolean</span> dataReady)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataReady = dataReady;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十二-Time-API-增强"><a href="#十二-Time-API-增强" class="headerlink" title="十二. Time API 增强"></a>十二. Time API 增强</h2><p>Time API已在JDK 9中得到增强，并在多个接口和类中使用了大量新方法。 Time API由<code>java.time.*</code>包组成，它们位于<code>java.base</code>模块中。</p>
<h3 id="1-Clock类"><a href="#1-Clock类" class="headerlink" title="1. Clock类"></a>1. Clock类</h3><p>Clock类中已经添加了以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Clock tickMillis(ZoneId zone)</span><br></pre></td></tr></table></figure>
<p><code>tickMillis()</code>方法返回一个时钟，提供了整个毫秒的当前瞬间记录。 时钟使用最好的系统时钟。时钟以高于毫秒的精度截断时间值。 调用此方法等同于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clock.tick(Clock.system(zone), Duration.ofMillis(1))</span><br></pre></td></tr></table></figure>
<h3 id="2-Duration类"><a href="#2-Duration类" class="headerlink" title="2. Duration类"></a>2. Duration类</h3><p>可以根据用途将Duration类中的新方法分为三类：</p>
<ul>
<li>将持续时间划分另一个持续时间的方法</li>
<li>根据特定时间单位获取持续时间的方法和获取特定部分持续时间（如天，小时，秒等）的方法。</li>
<li>将持续时间缩短到特定时间单位的方法</li>
</ul>
<p>在这里使用持续时间为23天，3小时45分30秒。 以下代码片段将其创建Duration对象，并将其引用保存在compTime的变量中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a duration of 23 days, 3 hours, 45 minutes, and 30 seconds</span></span><br><span class="line">Duration compTime = Duration.ofDays(<span class="number">23</span>)</span><br><span class="line">                        .plusHours(<span class="number">3</span>)</span><br><span class="line">                        .plusMinutes(<span class="number">45</span>)</span><br><span class="line">                        .plusSeconds(<span class="number">30</span>);</span><br><span class="line">System.out.println(<span class="string">"Duration: "</span> + compTime);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duration: PT555H45M30S</span><br></pre></td></tr></table></figure>
<p>通过将这些日期乘以24小时后，输出显示，此持续时间代表555小时，45分钟和30秒。</p>
<h4 id="1-将持续时间划分另一个持续时间"><a href="#1-将持续时间划分另一个持续时间" class="headerlink" title="1. 将持续时间划分另一个持续时间"></a>1. 将持续时间划分另一个持续时间</h4><p>此类别中只有一种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long dividedBy(Duration divisor)</span><br></pre></td></tr></table></figure>
<p><code>divideBy()</code>方法可以将持续时间划分另一个持续时间。 它返回特定除数在调用该方法的持续时间内发生的次数。 要知道在这段时间内有多少整周，可以使用七天作为持续时间来调用<code>divideBy()</code>方法。 以下代码片段显示了如何计算持续时间内的整天，周和小时数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> wholeDays = compTime.dividedBy(Duration.ofDays(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">long</span> wholeWeeks = compTime.dividedBy(Duration.ofDays(<span class="number">7</span>));</span><br><span class="line"><span class="keyword">long</span> wholeHours = compTime.dividedBy(Duration.ofHours(<span class="number">7</span>));</span><br><span class="line">System.out.println(<span class="string">"Number of whole days: "</span> + wholeDays);</span><br><span class="line">System.out.println(<span class="string">"Number of whole weeks: "</span> + wholeWeeks);</span><br><span class="line">System.out.println(<span class="string">"Number of whole hours: "</span> + wholeHours);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number of whole days: 23</span><br><span class="line">Number of whole weeks: 3</span><br><span class="line">Number of whole hours: 79</span><br></pre></td></tr></table></figure>
<h4 id="转换和检索部分持续时间"><a href="#转换和检索部分持续时间" class="headerlink" title="转换和检索部分持续时间"></a>转换和检索部分持续时间</h4><p>此类别中的Duration类添加了几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">toDaysPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toHoursPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toMillisPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toMinutesPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toNanosPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">toSeconds</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toSecondsPart</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>Duration类包含两组方法。它们被命名为<code>toXxx()</code>和<code>toXxxPart()</code>，其中Xxx可以是Days，Hours，Minutes，Seconds，Millis和Nanos。在此列表中，可能会注意到包含<code>toDaysPart()</code>，但是丢失了<code>toDays()</code>。如果看到某些Xxx中缺少一个方法，则表示这些方法已经存在于JDK 8中。例如，从JDK 8开始，<code>toDays()</code>方法已经在Duration类中。</p>
<p>名为<code>toXxx()</code>的方法将持续时间转换为Xxx时间单位并返回整个部分。名为<code>toXxxPart()</code>的方法会以几天为单位，以时间为单位分解持续时间：小时：分钟：秒：毫秒：纳秒，并从中返回Xxx部分。在这个例子中，toDays()将会将持续时间转换为天数并返回整个部分，这是23。<code>toDaysPart()</code>会将持续时间分解为23天：3Hours：45Minutes：30Seconds：0Millis：0Nanos，并返回第一部分，这是23。我们将相同的规则应用于toHours()和<code>toHoursPart()</code>方法。 toHours()方法会将持续时间转换为小时，并返回整个小时数，这是555。toHoursPart()方法会将持续时间与toDaysPart()方法一样分分解为一部分，并返回小时部分，这是。以下代码片段显示了几个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"toDays(): "</span> + compTime.toDays());</span><br><span class="line">System.out.println(<span class="string">"toDaysPart(): "</span> + compTime.toDaysPart());</span><br><span class="line">System.out.println(<span class="string">"toHours(): "</span> + compTime.toHours());</span><br><span class="line">System.out.println(<span class="string">"toHoursPart(): "</span> + compTime.toHoursPart());</span><br><span class="line">System.out.println(<span class="string">"toMinutes(): "</span> + compTime.toMinutes());</span><br><span class="line">System.out.println(<span class="string">"toMinutesPart(): "</span> + compTime.toMinutesPart());</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">toDays(): 23</span><br><span class="line">toDaysPart(): 23</span><br><span class="line">toHours(): 555</span><br><span class="line">toHoursPart(): 3</span><br><span class="line">toMinutes(): 33345</span><br><span class="line">toMinutesPart(): 45</span><br></pre></td></tr></table></figure>
<h4 id="3-截取持续时间"><a href="#3-截取持续时间" class="headerlink" title="3 截取持续时间"></a>3 截取持续时间</h4><p>此类别中的Duration类只添加了一种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duration truncatedTo(TemporalUnit unit)</span><br></pre></td></tr></table></figure>
<p><code>truncatedTo()</code>方法返回一个持续时间的副本，其概念时间单位小于被截断的指定单位。 指定的时间单位必须为DAYS或更小。 指定大于DAYS（如WEEKS和YEARS）的时间单位会引发运行时异常。</p>
<blockquote>
<p>Tips</p>
<p>JDK 8中的LocalTime和Instant类中已经存在truncatedTo(TemporalUnit unit)方法。</p>
</blockquote>
<p>以下代码片段显示了如何使用此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Truncated to DAYS: "</span> + compTime.truncatedTo(ChronoUnit.DAYS));</span><br><span class="line">System.out.println(<span class="string">"Truncated to HOURS: "</span> + compTime.truncatedTo(ChronoUnit.HOURS));</span><br><span class="line">System.out.println(<span class="string">"Truncated to MINUTES: "</span> + compTime.truncatedTo(ChronoUnit.MINUTES));</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Truncated to DAYS: PT552H</span><br><span class="line">Truncated to HOURS: PT555H</span><br><span class="line">Truncated to MINUTES: PT555H45M</span><br></pre></td></tr></table></figure>
<p>持续时间为<code>23Days:3Hours:45Minutes:30Seconds:0Millis:0Nanos</code>。 当将其截断为DAYS时，小于天数的所有部分将被删除，并返回23天，这与输出中显示的552小时相同。 当截断到HOURS时，它会将所有小于小时的部分删除掉，并返回555小时。 将其截断到MINUTES可保留分钟的部分，删除小于分钟的部分。</p>
<h3 id="3-ofInstant-工厂方法"><a href="#3-ofInstant-工厂方法" class="headerlink" title="3. ofInstant() 工厂方法"></a>3. ofInstant() 工厂方法</h3><p>Time API旨在提高开发人员的便利和效率。 有一些经常使用的用例，日期和时间之间的转换强制开发人员使用更多的方法调用而不是必需的。 两个这样的用例是：</p>
<ul>
<li>将java.util.Date转换为LocalDate</li>
<li>将Instant转换为LocalDate和LocalTime</li>
</ul>
<p>JDK 9在LocalDate和LocalTime类中添加了一个静态工厂方法，<code>ofInstant(Instant instant, ZoneId zone)</code>，以简化这两种类型的转换。 在ZonedDateTime，OffsetDateTime，LocalDateTime和OffsetTime类中，JDK 8已经有了这种工厂方法。 以下代码片段显示了JDK 8和JDK 9的两种方法——将java.util.Date转换为LocalDate：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In JDK 8</span></span><br><span class="line">Date dt = <span class="keyword">new</span> Date();</span><br><span class="line">LocalDate ld= dt.toInstant()</span><br><span class="line">                 .atZone(ZoneId.systemDefault())</span><br><span class="line">                 .toLocalDate();</span><br><span class="line">System.out.println(<span class="string">"Current Local Date: "</span> + ld);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In JDK 9</span></span><br><span class="line">LocalDate ld2 = LocalDate.ofInstant(dt.toInstant(), ZoneId.systemDefault());</span><br><span class="line">System.out.println(<span class="string">"Current Local Date: "</span> + ld2);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Current Local Date: 2017-02-11</span><br><span class="line">Current Local Date: 2017-02-11</span><br></pre></td></tr></table></figure>
<p>以下代码片段显示了两种方式，在DK 8和JDK 9，将Instant转换为LocalDate和LocalTime：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In JDK 8</span></span><br><span class="line">Instant now = Instant.now();</span><br><span class="line">ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">ZonedDateTime zdt = now.atZone(zone);</span><br><span class="line">LocalDate ld3 = zdt.toLocalDate();</span><br><span class="line">LocalTime lt3 = zdt.toLocalTime();</span><br><span class="line">System.out.println(<span class="string">"Local Date: "</span> + ld3 + <span class="string">", Local Time:"</span> + lt3);</span><br><span class="line"><span class="comment">// In JDK 9        </span></span><br><span class="line">LocalDate ld4 = LocalDate.ofInstant(now, zone);</span><br><span class="line">LocalTime lt4 = LocalTime.ofInstant(now, zone);</span><br><span class="line">System.out.println(<span class="string">"Local Date: "</span> + ld4 + <span class="string">", Local Time:"</span> + lt4);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Local Date: 2017-02-11, Local Time:22:13:31.919339400</span><br><span class="line">Local Date: 2017-02-11, Local Time:22:13:31.919339400</span><br></pre></td></tr></table></figure>
<h3 id="4-获取纪元秒"><a href="#4-获取纪元秒" class="headerlink" title="4. 获取纪元秒"></a>4. 获取纪元秒</h3><p>有时想从LocalDate，LocalTime和OffsetTime获取自1970-01-01T00：00：00Z的时代以来的秒数。 在JDK 8中，<code>OffsetDateTime</code>类包含一个<code>toEpochSecond()`</code>方法。 如果要从<code>ZonedDateTime</code>获取时代以来的秒数，则必须使用它的<code>toOffsetDateTime()</code>方法将其转换为<code>OffsetDateTime</code>，并使用<code>OffsetDateTime类的toEpochSecond()</code>方法。 JDK 8没有包含用于<code>LocalDate</code>，<code>LocalTime</code>和<code>OffsetTime</code>类的<code>toEpochSecond()</code>方法。 JDK 9添加了这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate.toEpochSecond(LocalTime time, ZoneOffset offset)</span><br><span class="line">LocalTime.toEpochSecond(LocalDate date, ZoneOffset offset)</span><br><span class="line">OffsetTime.toEpochSecond(LocalDate date)</span><br></pre></td></tr></table></figure>
<p>为什么这些类的<code>toEpochSecond()</code>方法的签名不同？ 要从时代<code>1970-01-01T00：00：00Z</code>获得秒数，需要定义另一个Instant。 一个Instant可以用三个部分定义：日期，时间，区域偏移。 LocalDate和LocalTime类只包含一个Instant的三个部分之一。 OffsetTime类包含两个部分，一个时间和一个偏移量。 缺少的部分需要被这些类指定为参数。 因此，这些类包含toEpochSecond()方法，该方法的参数指定了用于定义Instant的缺失部分。 以下代码片段使用相同的Instant从三个类中获取时代的秒数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld = LocalDate.of(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">12</span>);</span><br><span class="line">LocalTime lt = LocalTime.of(<span class="number">9</span>, <span class="number">15</span>, <span class="number">45</span>);</span><br><span class="line">ZoneOffset offset = ZoneOffset.ofHours(<span class="number">6</span>);</span><br><span class="line">OffsetTime ot = OffsetTime.of(lt, offset);</span><br><span class="line"><span class="keyword">long</span> s1 = ld.toEpochSecond(lt, offset);</span><br><span class="line"><span class="keyword">long</span> s2 = lt.toEpochSecond(ld, offset);</span><br><span class="line"><span class="keyword">long</span> s3 = ot.toEpochSecond(ld);</span><br><span class="line">System.out.println(<span class="string">"LocalDate.toEpochSecond(): "</span> + s1);</span><br><span class="line">System.out.println(<span class="string">"LocalTime.toEpochSecond(): "</span> + s2);</span><br><span class="line">System.out.println(<span class="string">"OffsetTime.toEpochSecond(): "</span> + s3);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate.toEpochSecond(): 1486869345</span><br><span class="line">LocalTime.toEpochSecond(): 1486869345</span><br><span class="line">OffsetTime.toEpochSecond(): 1486869345</span><br></pre></td></tr></table></figure>
<h3 id="5-LocalDate流"><a href="#5-LocalDate流" class="headerlink" title="5. LocalDate流"></a>5. LocalDate流</h3><p>JDK 9可以轻松地跨越两个给定日期之间的所有日期，可以是某时的一天或给定一个区间时段。 以下两种方法已添加到LocalDate类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;LocalDate&gt; datesUntil(LocalDate endExclusive)</span><br><span class="line">Stream&lt;LocalDate&gt; datesUntil(LocalDate endExclusive, Period step)</span><br></pre></td></tr></table></figure>
<p>这些方法产生LocalDates的顺序排序流。 流中的第一个元素是调用该方法的LocalDate。<code>datesUntil(LocalDate endExclusive)</code>方法一次一天地增加流中的元素，而<code>datesUntil(LocalDate endExclusive, Period step)</code>方法会按照指定的步骤增加它们。 指定的结束日期是排他的。 可以在返回的流上执行几个有用的计算。 以下代码片段计算了2017年的星期数。请注意，代码使用2018年1月1日作为最后一个日期，它是排他的，这将使流返回2017年的所有日期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> sundaysIn2017 = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">                              .datesUntil(LocalDate.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">                              .filter(ld -&gt; ld.getDayOfWeek() == DayOfWeek.SUNDAY)</span><br><span class="line">                              .count();        </span><br><span class="line">System.out.println(<span class="string">"Number of Sundays in 2017: "</span> + sundaysIn2017);</span><br></pre></td></tr></table></figure>
<p>打印的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number of Sundays in 2017: 53</span><br></pre></td></tr></table></figure>
<p>以下代码片段将于2017年1月1日（含）之间打印至2022年1月1日（不包含），即星期五落在本月十三日的日期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">         .datesUntil(LocalDate.of(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">         .filter(ld -&gt; ld.getDayOfMonth() == <span class="number">13</span> &amp;&amp; ld.getDayOfWeek() == DayOfWeek.FRIDAY)</span><br><span class="line">         .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Fridays that fall on 13th of the month between 2017 - 2021 (inclusive):</span><br><span class="line">2017-01-13</span><br><span class="line">2017-10-13</span><br><span class="line">2018-04-13</span><br><span class="line">2018-07-13</span><br><span class="line">2019-09-13</span><br><span class="line">2019-12-13</span><br><span class="line">2020-03-13</span><br><span class="line">2020-11-13</span><br><span class="line">2021-08-13</span><br></pre></td></tr></table></figure>
<p>以下代码片段打印2017年每月的最后一天：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Last Day of months in 2017:"</span>);</span><br><span class="line">LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">31</span>)                </span><br><span class="line">         .datesUntil(LocalDate.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>), Period.ofMonths(<span class="number">1</span>))</span><br><span class="line">         .map(ld -&gt; ld.format(DateTimeFormatter.ofPattern(<span class="string">"EEE MMM dd, yyyy"</span>)))</span><br><span class="line">         .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Last Day of months in 2017:</span><br><span class="line">Tue Jan 31, 2017</span><br><span class="line">Tue Feb 28, 2017</span><br><span class="line">Fri Mar 31, 2017</span><br><span class="line">Sun Apr 30, 2017</span><br><span class="line">Wed May 31, 2017</span><br><span class="line">Fri Jun 30, 2017</span><br><span class="line">Mon Jul 31, 2017</span><br><span class="line">Thu Aug 31, 2017</span><br><span class="line">Sat Sep 30, 2017</span><br><span class="line">Tue Oct 31, 2017</span><br><span class="line">Thu Nov 30, 2017</span><br><span class="line">Sun Dec 31, 2017</span><br></pre></td></tr></table></figure>
<h3 id="6-新的格式化选项"><a href="#6-新的格式化选项" class="headerlink" title="6. 新的格式化选项"></a>6. 新的格式化选项</h3><p>JDK 9向Time API添加了一些格式化选项。 以下部分将详细介绍这些改动。</p>
<h4 id="1-修正儒略日格式"><a href="#1-修正儒略日格式" class="headerlink" title="1. 修正儒略日格式"></a>1. 修正儒略日格式</h4><p>可以在日期时间格式化程序模式中使用小写字母g，它将日期部分格式化为修正儒略日作为整数。 可以多次重复多次使用g，例如ggg，如果结果中的位数小于g指定的数目，则会对结果进行零填充。 <a href="http://www.unicode.org/reports/tr35/tr35-41/tr35-dates.html#Date_Format_Patterns上的定义了格式化程序中字母g的含义如下：" target="_blank" rel="noopener">http://www.unicode.org/reports/tr35/tr35-41/tr35-dates.html#Date_Format_Patterns上的定义了格式化程序中字母g的含义如下：</a></p>
<p>修正儒略日。 这与以往的修正儒略日不同。 首先，它在当地时区午夜，而不是格林尼治标准时间中午划定天数。 二是本地数字; 也就是说，这取决于当地的时区。 它可以被认为是包含所有日期相关字段的单个数字。</p>
<blockquote>
<p>Tips</p>
<p>大写字母G被定义为JDK 8中的日期和时间格式化器符号。</p>
</blockquote>
<p>以下代码片段显示了如何使用修正儒略日字符g格式化ZonedDateTime：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class="line">System.out.println(<span class="string">"Current ZonedDateTime: "</span> + zdt);               </span><br><span class="line">System.out.println(<span class="string">"Modified Julian Day (g): "</span> +</span><br><span class="line">                zdt.format(DateTimeFormatter.ofPattern(<span class="string">"g"</span>)));</span><br><span class="line">System.out.println(<span class="string">"Modified Julian Day (ggg): "</span> +</span><br><span class="line">                zdt.format(DateTimeFormatter.ofPattern(<span class="string">"ggg"</span>)));</span><br><span class="line">System.out.println(<span class="string">"Modified Julian Day (gggggg): "</span> +</span><br><span class="line">                zdt.format(DateTimeFormatter.ofPattern(<span class="string">"gggggg"</span>)));</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Current ZonedDateTime: 2017-02-12T11:49:03.364431100-06:00[America/Chicago]</span><br><span class="line">Modified Julian Day (g): 57796</span><br><span class="line">Modified Julian Day (ggg): 57796</span><br><span class="line">Modified Julian Day (gggggg): 057796</span><br></pre></td></tr></table></figure>
<h4 id="2-通用时区名称"><a href="#2-通用时区名称" class="headerlink" title="2. 通用时区名称"></a>2. 通用时区名称</h4><p>JDK 8有两个字母V和z来格式化日期和时间的时区。 字母V产生区域ID，例如“America / Los_Angeles; Z; -08：30”，字母z产生区域名称，如中央标准时间和CST。</p>
<p>JDK 9将小写字母v添加为格式化符号，生成通用的非定位区域名称，如中央时间或CT。 “非定位”意味着它不会识别与UTC的偏移量。 它指的是墙上的时间——墙壁上的时钟显示的时间。 例如，中央时间上午8时，2017年3月1日将有UTC-06的偏移量，而2017年3月19日的UTC-05偏移量。通用非定位区域名称不指定时区偏移量。 可以使用两种格式-v和vvvv来分别以短格式（例如CT）和长格式（例如中央时间）生成通用非定位区域名称。 以下代码片段显示了由V，Z和V格式化符号产生的格式化结果的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class="line">System.out.println(<span class="string">"Current ZonedDateTime: "</span> + zdt);               </span><br><span class="line">System.out.println(<span class="string">"Using VV: "</span> +</span><br><span class="line">                zdt.format(DateTimeFormatter.ofPattern(<span class="string">"MM/dd/yyyy HH:mm VV"</span>)));</span><br><span class="line">System.out.println(<span class="string">"Using z: "</span> +</span><br><span class="line">                zdt.format(DateTimeFormatter.ofPattern(<span class="string">"MM/dd/yyyy HH:mm z"</span>)));</span><br><span class="line">System.out.println(<span class="string">"Using zzzz: "</span> +</span><br><span class="line">                zdt.format(DateTimeFormatter.ofPattern(<span class="string">"MM/dd/yyyy HH:mm zzzz"</span>)));</span><br><span class="line">System.out.println(<span class="string">"Using v: "</span> +</span><br><span class="line">                zdt.format(DateTimeFormatter.ofPattern(<span class="string">"MM/dd/yyyy HH:mm v"</span>)));</span><br><span class="line">System.out.println(<span class="string">"Using vvvv: "</span> +</span><br><span class="line">                zdt.format(DateTimeFormatter.ofPattern(<span class="string">"MM/dd/yyyy HH:mm vvvv"</span>)));</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Current ZonedDateTime: <span class="number">2017</span>-<span class="number">02</span>-<span class="number">12</span>T12:<span class="number">30</span>:<span class="number">08.975373900</span>-<span class="number">06</span>:<span class="number">00</span>[America/Chicago]</span><br><span class="line">Using VV: <span class="number">02</span>/<span class="number">12</span>/<span class="number">2017</span> <span class="number">12</span>:<span class="number">30</span> America/Chicago</span><br><span class="line">Using z: <span class="number">02</span>/<span class="number">12</span>/<span class="number">2017</span> <span class="number">12</span>:<span class="number">30</span> CST</span><br><span class="line">Using zzzz: <span class="number">02</span>/<span class="number">12</span>/<span class="number">2017</span> <span class="number">12</span>:<span class="number">30</span> Central Standard Time</span><br><span class="line">Using v: <span class="number">02</span>/<span class="number">12</span>/<span class="number">2017</span> <span class="number">12</span>:<span class="number">30</span> CT</span><br><span class="line">Using vvvv: <span class="number">02</span>/<span class="number">12</span>/<span class="number">2017</span> <span class="number">12</span>:<span class="number">30</span> Central Time</span><br></pre></td></tr></table></figure>
<h2 id="十三-使用Scanner进行流操作"><a href="#十三-使用Scanner进行流操作" class="headerlink" title="十三. 使用Scanner进行流操作"></a>十三. 使用Scanner进行流操作</h2><p>JDK 9将以下三个方法添加到java.util.Scanner中。 每个方法返回一个Stream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;MatchResult&gt; <span class="title">findAll</span><span class="params">(String patternString)</span></span></span><br><span class="line"><span class="function">Stream&lt;MatchResult&gt; <span class="title">findAll</span><span class="params">(Pattern pattern)</span></span></span><br><span class="line"><span class="function">Stream&lt;String&gt; <span class="title">tokens</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><code>findAll()</code>方法返回具有所有匹配结果的流。 调用<code>findAll(patternString)</code>相当于调用<code>findAll(Pattern.compile(patternString))</code>。<code>tokens()</code>方法使用当前的分隔符从scanner返回令牌流。下面包含一个程序，显示如何仅使用<code>findAll()</code>方法从字符串中收集单词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScannerTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.MatchResult;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String patternString = <span class="string">"\\b\\w+\\b"</span>;</span><br><span class="line">        String input = <span class="string">"A test string,\n which contains a new line."</span>;</span><br><span class="line">        List&lt;String&gt; words = <span class="keyword">new</span> Scanner(input)</span><br><span class="line">                .findAll(patternString)</span><br><span class="line">                .map(MatchResult::group)</span><br><span class="line">                .collect(toList());</span><br><span class="line">        System.out.println(<span class="string">"Input: "</span> + input);</span><br><span class="line">        System.out.println(<span class="string">"Words: "</span> + words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A test string,</span><br><span class="line"> which contains a new line.</span><br><span class="line">Words: [A, test, string, which, contains, a, new, line]</span><br></pre></td></tr></table></figure>
<h2 id="十四-Matcher类的增强"><a href="#十四-Matcher类的增强" class="headerlink" title="十四. Matcher类的增强"></a>十四. Matcher类的增强</h2><p><code>java.util.regex.Matcher</code>类在JDK 9中添加了一些新的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matcher <span class="title">appendReplacement</span><span class="params">(StringBuilder sb,  String replacement)</span></span></span><br><span class="line"><span class="function">StringBuilder <span class="title">appendTail</span><span class="params">(StringBuilder sb)</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(Function&lt;MatchResult,String&gt; replacer)</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(Function&lt;MatchResult,String&gt; replacer)</span></span></span><br><span class="line"><span class="function">Stream&lt;MatchResult&gt; <span class="title">results</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>JDK 8中的Matcher类在此列表中已经有前四个方法。 在JDK 9中，它们已经重载了。 <code>appendReplacement()</code>和<code>appendTail()</code>方法用于使用StringBuffer。 现在他们也可以使用StringBuilder。 <code>replaceAll()</code>和<code>replaceFirst()</code>方法将String作为参数。 在JDK 9中，它们已经被重载，以Function&lt;T,R&gt;作为参数。</p>
<p><code>results()</code>方法返回其元素为MatchResult类型的流中的匹配结果。 可以查询MatchResult获取结果作为字符串。 可以将Matcher的结果作为JDK 8中的流进行处理。但是逻辑并不简单。 results()方法不会重置matcher。 如果要重置matcher，不要忘记调用其reset()方法将其重置为所需的位置。下面显示了这种方法的一些有趣的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MatcherTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatcherTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A regex to match 7-digit or 10-digit phone numbers</span></span><br><span class="line">        String regex = <span class="string">"\\b(\\d&#123;3&#125;)?(\\d&#123;3&#125;)(\\d&#123;4&#125;)\\b"</span>;</span><br><span class="line">        <span class="comment">// An input string</span></span><br><span class="line">        String input = <span class="string">"1, 3342229999, 2330001, 6159996666, 123, 3340909090"</span>;</span><br><span class="line">        <span class="comment">// Create a matcher</span></span><br><span class="line">        Matcher matcher = Pattern.compile(regex)</span><br><span class="line">                                  .matcher(input);</span><br><span class="line">        <span class="comment">// Collect formatted phone numbers into a list</span></span><br><span class="line">        List&lt;String&gt; phones = matcher.results()</span><br><span class="line">                          .map(mr -&gt; (mr.group(<span class="number">1</span>) == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">"("</span> + mr.group(<span class="number">1</span>) + <span class="string">") "</span>)</span><br><span class="line">                                      + mr.group(<span class="number">2</span>) + <span class="string">"-"</span> + mr.group(<span class="number">3</span>))</span><br><span class="line">                          .collect(toList());</span><br><span class="line">        System.out.println(<span class="string">"Phones: "</span> + phones);</span><br><span class="line">        <span class="comment">// Reset the matcher, so we can reuse it from start</span></span><br><span class="line">        matcher.reset();</span><br><span class="line">        <span class="comment">// Get distinct area codes</span></span><br><span class="line">        Set&lt;String&gt; areaCodes = matcher.results()</span><br><span class="line">                                       .filter(mr -&gt; mr.group(<span class="number">1</span>) != <span class="keyword">null</span>)</span><br><span class="line">                                       .map(mr -&gt; mr.group(<span class="number">1</span>))</span><br><span class="line">                                       .collect(toSet());</span><br><span class="line">        System.out.println(<span class="string">"Distinct Area Codes:: "</span> + areaCodes);                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Phones: [(334) 222-9999, 233-0001, (615) 999-6666, (334) 090-9090] Distinct Area Codes:: [334, 615]</span><br></pre></td></tr></table></figure>
<p>main()方法声明两个名regex和input的局部变量。 正则表达式变量包含一个正则表达式，以匹配7位数或10位数字。 将使用它在输入字符串中查找电话号码。 input变量保存有嵌入电话号码的文本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A regex to match 7-digit or 10-digit phone numbers</span></span><br><span class="line">String regex = <span class="string">"\\b(\\d&#123;3&#125;)?(\\d&#123;3&#125;)(\\d&#123;4&#125;)\\b"</span>;</span><br><span class="line"><span class="comment">// An input string</span></span><br><span class="line">String input = <span class="string">"1, 3342229999, 2330001, 6159996666, 123, 3340909090"</span>;</span><br></pre></td></tr></table></figure>
<p>接下来，将正则表达式编译为Pattern对象并获取matcher：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a matcher</span></span><br><span class="line">Matcher matcher = Pattern.compile(regex)</span><br><span class="line">                         .matcher(input);</span><br></pre></td></tr></table></figure>
<p>要将10位电话号码格式化为（nnn）nnn-nnnn和7位数电话号码为nnn-nnnn的格式。 最后，要将所有格式化的电话号码收集到List<string>中。 以下语句执行：</string></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collect formatted phone numbers into a list</span></span><br><span class="line">List&lt;String&gt; phones = matcher.results()</span><br><span class="line">                             .map(mr -&gt; (mr.group(<span class="number">1</span>) == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">"("</span> + mr.group(<span class="number">1</span>) + <span class="string">") "</span>)</span><br><span class="line">                                     + mr.group(<span class="number">2</span>) + <span class="string">"-"</span> + mr.group(<span class="number">3</span>))</span><br><span class="line">                             .collect(toList());</span><br></pre></td></tr></table></figure>
<p>请注意使用接收<code>MatchResult的map()</code>方法，并将格式化的电话号码返回为String。当一个匹配是一个7位数的电话号码时，组1将为空现在，要重新使用matcher， 以10位数的电话号码查找不同的区号。必须重置matcher，所以下一个匹配从输入字符串的开始处开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reset the matcher, so we can reuse it from start</span></span><br><span class="line">matcher.reset();</span><br></pre></td></tr></table></figure>
<p><code>MatchResult</code>中的第一个组包含区号。 需要滤除7位数的电话号码，并在Set <string>中收集组1的值，以获得一组不同的区号。 以下语句是这样做的：</string></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get distinct area codes</span></span><br><span class="line">Set&lt;String&gt; areaCodes = matcher.results()</span><br><span class="line">                               .filter(mr -&gt; mr.group(<span class="number">1</span>) != <span class="keyword">null</span>)</span><br><span class="line">                               .map(mr -&gt; mr.group(<span class="number">1</span>))</span><br><span class="line">                               .collect(toSet());</span><br></pre></td></tr></table></figure>
<h2 id="十五-Object类的增强"><a href="#十五-Object类的增强" class="headerlink" title="十五. Object类的增强"></a>十五. Object类的增强</h2><p><code>java.util.Objects</code>类包含对对象进行操作的静态实用方法。 通常，它们用于验证方法的参数，例如，检查方法的参数是否为空。 JDK 9将以下静态方法添加到此类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">requireNonNullElse</span><span class="params">(T obj, T defaultObj)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">requireNonNullElseGet</span><span class="params">(T obj, Supplier&lt;? extends T&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkFromIndexSize</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> size, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkFromToIndex</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure>
<p>JDK 8已经有了三个<code>requireNonNull()`</code>重载方法。 该方法用于检查值为非空值。 如果值为null，则会抛出NullPointerException。 JDK 9添加了这个方法的两个版本。</p>
<p>如果obj为非空，则<code>requireNonNullElse(T obj, T defaultObj)`</code>方法返回obj。 如果obj为空，并且defaultObj为非空，则返回defaultObj。 如果obj和defaultObj都为空，则会抛出NullPointerException异常。</p>
<p><code>requireNonNullElseGet(T obj, Supplier&lt;? extends T&gt; supplier)</code>方法的工作方式与<code>requireNonNullElse(T obj, T defaultObj)</code>方法相同，前者使用Supplier获取默认值。 如果非空，它返回obj。 如果Supplier非空，并返回非空值，则返回从Supplier返回的值。 否则，抛出NullPointerException异常。</p>
<p><code>checkXxx()</code>的方法意在用于检查索引或子范围是否在某一范围内。当使用数组和集合时，它们很有用，需要处理索引和子范围。如果索引或子范围超出范围，这些方法将抛出IndexOutOfBoundsException。</p>
<p><code>checkFromIndexSize(int fromIndex，int size，int length)</code>方法检查指定的子范围，从inIndex（包括）到fromIndex + size（不包括）是否在范围内，范围是从0（含）到length。如果任何参数为负整数或子范围超出范围，则抛出IndexOutOfBoundsException。如果子范围在范围内，则返回fromIndex。假设有一个接受索引和大小的方法，并从数组或列表返回一个子范围。可以使用此方法来检查所请求的子范围是否在数组或列表的范围内。</p>
<p><code>checkFromToIndex(int fromIndex, int toIndex, int length)</code>方法检查指定的子范围，从inIndex（包括）到toIndex（不包含）是否在范围内，范围为为0（含）到length（不包含）。如果任何参数是负整数或子范围超出范围，则抛出IndexOutOfBoundsException。如果子范围在范围内，则返回fromIndex。在使用数组和List时用于子范围检查是非常有用的。</p>
<p><code>checkIndex(int index, int length)</code>方法检查指定的索引是否在范围内，为0（含）到length（不包含）。如果任何参数为负整数或索引超出范围，则抛出IndexOutOfBoundsException。如果index在范围内，则返回索引。当方法接收到索引并返回数组中的值或该索引的List时，它很有用。</p>
<h2 id="十六-数组比较"><a href="#十六-数组比较" class="headerlink" title="十六. 数组比较"></a>十六. 数组比较</h2><p><code>java.util.Arrays</code>类由静态实用方法组成，可用于对数组执行各种操作，例如排序，比较，转换为流等。在JDK 9中，此类已经获得了几种方法，可以比较数组和切片（slices）。 新方法分为三类：</p>
<ul>
<li>比较两个数组或它们的切片是否相等性</li>
<li>按字典顺序比较两个数组</li>
<li>查找两个数组中的第一个不匹配的索引</li>
</ul>
<p>添加到此类的方法列表是很大的。 每个类别中的方法对于所有原始类型和对象数组都是重载的。 有关完整列表，请参阅Arrays类的API文档。</p>
<p><code>equals()</code>方法可以比较两个数组的相等性。 如果数组或部分数组中的元素数量相同，并且数组或部分数组中所有对应的元素对相等，则两个数组被认为是相等的。 以下是int的两个版本的<code>equals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> aFromIndex, <span class="keyword">int</span> aToIndex, <span class="keyword">int</span>[] b, <span class="keyword">int</span> bFromIndex, <span class="keyword">int</span> bToIndex)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个版本允许比较两个数组之间的相等性，并且存在于JDK 9之前。第二个版本允许将两个数组的部分进行比较，以便在JDK 9中添加相等。fromIndex（包含）和toIndex（不包含）参数决定要比较的两个数组的范围。 如果两个数组相等，则该方法返回true，否则返回false。 如果两个数组都为空，则认为两个数组相等。</p>
<p>JDK 9添加了几个<code>compare()</code>和<code>compareUnsigned()</code>的方法。 这两种方法都按字典顺序比较数组或部分数组中的元素。</p>
<p>compareUnsigned()方法将整数值视为无符号。 空数组的字符拼写小于非空数组。 两个空数组相等。 以下是对于int的compare()方法的两个版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> aFromIndex, <span class="keyword">int</span> aToIndex, <span class="keyword">int</span>[] b, <span class="keyword">int</span> bFromIndex, <span class="keyword">int</span> bToIndex)</span></span></span><br></pre></td></tr></table></figure>
<p>如果第一个和第二个数组相等并且包含相同的元素，<code>compare()</code>方法返回0; 如果第一个数组在字典上小于第二个数组，则返回小于0的值; 并且如果第一个数组在字典上大于第二个数组则返回大于0的值。</p>
<p><code>mismatch()</code>方法比较两个数组或数组的一部分。 以下是int的两个版本的<code>mismatch()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mismatch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mismatch</span> <span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> aFromIndex, <span class="keyword">int</span> aToIndex, <span class="keyword">int</span>[] b, <span class="keyword">int</span> bFromIndex, <span class="keyword">int</span> bToIndex)</span></span></span><br></pre></td></tr></table></figure>
<p><code>mismatch()</code>方法返回第一个不匹配的索引。 如果没有不匹配，则返回-1。 如果任一数组为空，则抛出NullPointerException。 下包含一个比较两个数组及其部分数组的完整程序。 该程序使用两个int数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayComparision.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayComparison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] a2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] a3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">// Print original arrays</span></span><br><span class="line">        System.out.println(<span class="string">"Three arrays:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"a1: "</span> + Arrays.toString(a1));</span><br><span class="line">        System.out.println(<span class="string">"a2: "</span> + Arrays.toString(a2));</span><br><span class="line">        System.out.println(<span class="string">"a3: "</span> + Arrays.toString(a3));</span><br><span class="line">        <span class="comment">// Compare arrays for equality</span></span><br><span class="line">        System.out.println(<span class="string">"\nComparing arrays using equals() method:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Arrays.equals(a1, a2): "</span> + Arrays.equals(a1, a2));</span><br><span class="line">        System.out.println(<span class="string">"Arrays.equals(a1, a3): "</span> + Arrays.equals(a1, a3));</span><br><span class="line">        System.out.println(<span class="string">"Arrays.equals(a1, 0, 2, a2, 0, 2): "</span> +</span><br><span class="line">                           Arrays.equals(a1, <span class="number">0</span>, <span class="number">2</span>, a2, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// Compare arrays lexicographically</span></span><br><span class="line">        System.out.println(<span class="string">"\nComparing arrays using compare() method:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Arrays.compare(a1, a2): "</span> + Arrays.compare(a1, a2));</span><br><span class="line">        System.out.println(<span class="string">"Arrays.compare(a2, a1): "</span> + Arrays.compare(a2, a1));</span><br><span class="line">        System.out.println(<span class="string">"Arrays.compare(a1, a3): "</span> + Arrays.compare(a1, a3));</span><br><span class="line">        System.out.println(<span class="string">"Arrays.compare(a1, 0, 2, a2, 0, 2): "</span> +</span><br><span class="line">                           Arrays.compare(a1, <span class="number">0</span>, <span class="number">2</span>, a2, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// Find the mismatched index in arrays</span></span><br><span class="line">        System.out.println(<span class="string">"\nFinding mismatch using the mismatch() method:"</span>);                </span><br><span class="line">        System.out.println(<span class="string">"Arrays.mismatch(a1, a2): "</span> + Arrays.mismatch(a1, a2));</span><br><span class="line">        System.out.println(<span class="string">"Arrays.mismatch(a1, a3): "</span> + Arrays.mismatch(a1, a3));</span><br><span class="line">        System.out.println(<span class="string">"Arrays.mismatch(a1, 0, 5, a2, 0, 1): "</span> +</span><br><span class="line">                            Arrays.mismatch(a1, <span class="number">0</span>, <span class="number">5</span>, a2, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a1: [1, 2, 3, 4, 5]</span><br><span class="line">a2: [1, 2, 7, 4, 5]</span><br><span class="line">a3: [1, 2, 3, 4, 5]</span><br><span class="line">Comparing arrays using equals() method:</span><br><span class="line">Arrays.equals(a1, a2): false</span><br><span class="line">Arrays.equals(a1, a3): true</span><br><span class="line">Arrays.equals(a1, 0, 2, a2, 0, 2): true</span><br><span class="line">Comparing arrays using compare() method:</span><br><span class="line">Arrays.compare(a1, a2): -1</span><br><span class="line">Arrays.compare(a2, a1): 1</span><br><span class="line">Arrays.compare(a1, a3): 0</span><br><span class="line">Arrays.compare(a1, 0, 2, a2, 0, 2): 0</span><br><span class="line">Finding mismatch using the mismatch() method:</span><br><span class="line">Arrays.mismatch(a1, a2): 2</span><br><span class="line">Arrays.mismatch(a1, a3): -1</span><br><span class="line">Arrays.mismatch(a1, 0, 5, a2, 0, 1): 1</span><br></pre></td></tr></table></figure>
<h2 id="十七-Applet-API已经废弃"><a href="#十七-Applet-API已经废弃" class="headerlink" title="十七. Applet API已经废弃"></a>十七. Applet API已经废弃</h2><p>Java applets需要Java浏览器插件才能正常工作。 许多浏览器供应商已经删除了对Java浏览器插件的支持，或者将在不久的将来删除它。 如果浏览器不支持Java插件，则不能使用applet，因此没有理由使用Applet API。 JDK 9弃用了Applet API。 但是，它将不会在JDK 10中被删除。如果计划在将来的版本中被删除，开发人员将提前发布一个通知。 以下类和接口已被弃用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.applet.AppletStub</span><br><span class="line">java.applet.Applet</span><br><span class="line">java.applet.AudioClip</span><br><span class="line">java.applet.AppletContext</span><br><span class="line">javax.swing.JApplet</span><br></pre></td></tr></table></figure>
<p>在JDK 9中，所有AWT和Swing相关类都打包在java.desktop模块中。 这些不推荐的类和接口也在同一个模块中。</p>
<p>appletviewer工具随其JDK在bin目录中提供，用于测试applet。 该工具也在JDK 9中不推荐使用。在JDK 9中运行该工具会打印一个弃用警告。</p>
<h2 id="十八-Javadoc增强"><a href="#十八-Javadoc增强" class="headerlink" title="十八. Javadoc增强"></a>十八. Javadoc增强</h2><p>TODO</p>
<h2 id="十九-本地桌面功能"><a href="#十九-本地桌面功能" class="headerlink" title="十九. 本地桌面功能"></a>十九. 本地桌面功能</h2><p>TODO</p>
<h2 id="二十-对象反序列化过滤器"><a href="#二十-对象反序列化过滤器" class="headerlink" title="二十. 对象反序列化过滤器"></a>二十. 对象反序列化过滤器</h2><p>Java可以对对象进行序列化和反序列化。 为了解决反序列化带来的安全风险，JDK 9引入了可以用来验证反序列化对象的对象输入过滤器的概念，如果不通过测试，则可以停止反序列化过程。 对象输入过滤器是添加到JDK 9的新接口java.io.ObjectInputFilter的实例。过滤器可以基于以下一个或多个条件：</p>
<ul>
<li>数组的长度反序列化</li>
<li>嵌套对象的深度反序列化</li>
<li>对象引用数反序列化</li>
<li>对象的类被反序列化</li>
<li>从输入流消耗的字节数</li>
</ul>
<p>ObjectInputFilter接口只包含一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputFilter.<span class="function">Status <span class="title">checkInput</span><span class="params">(ObjectInputFilter.FilterInfo filterInfo)</span></span></span><br></pre></td></tr></table></figure>
<p>可以指定要用于反序列化所有对象的全局过滤器。 可以通过为对象输入流设置本地过滤器来重写每个ObjectInputStream上的全局过滤器。 可以没有全局过滤器，并为每个对象输入流指定本地过滤器。 有几种方法来创建和指定过滤器。 本节首先介绍添加到JDK 9中的类和接口，需要使用这些类和接口来处理过滤器：</p>
<ul>
<li>ObjectInputFilter</li>
<li>ObjectInputFilter.Config</li>
<li>ObjectInputFilter.FilterInfo</li>
<li>ObjectInputFilter.Status</li>
</ul>
<p>ObjectInputFilter接口的实例表示过滤器。 可以通过在类中实现此接口来创建过滤器。 或者，可以使用<code>ObjectInputFilter.Config</code>类的<code>createFilter(String pattern)</code>方法从字符串获取其实例。</p>
<p><code>ObjectInputFilter.Config</code>是一个嵌套的静态实用类，用于两个目的：</p>
<ul>
<li>获取并设置全局过滤器</li>
<li>从指定字符串的模式中创建过滤器</li>
</ul>
<p><code>ObjectInputFilter.Config</code>类包含以下三种静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ObjectInputFilter <span class="title">createFilter</span><span class="params">(String pattern)</span></span></span><br><span class="line"><span class="function">ObjectInputFilter <span class="title">getSerialFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSerialFilter</span><span class="params">(ObjectInputFilter filter)</span></span></span><br></pre></td></tr></table></figure>
<p><code>createFilter()</code>方法接受一个描述过滤器的模式，并返回<code>ObjectInputFilter</code>接口的实例。 以下代码片段创建一个过滤器，指定反序列化数组的长度不应超过4：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String pattern = <span class="string">"maxarray=4"</span>;</span><br><span class="line">ObjectInputFilter filter = ObjectInputFilter.Config.createFilter(pattern);</span><br></pre></td></tr></table></figure>
<p>可以在一个过滤器中指定多个模式。 它们用分号（;）分隔。 以下代码片段从两种模式创建一个过滤器。 如果遇到长度大于4的数组或串行化对象的大小大于1024字节，则过滤器将拒绝对象反序列化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String pattern = &quot;maxarray=4;maxbytes=1024&quot;;</span><br><span class="line">ObjectInputFilter filter = ObjectInputFilter.Config.createFilter(pattern);</span><br></pre></td></tr></table></figure>
<p>指定过滤器模式有几个规则。 如果喜欢在Java代码中编写过滤器逻辑，可以通过创建实现<code>ObjectInputFilter</code>接口的类并将其写入其<code>checkInput()</code>方法来实现。 如果要从字符串中的模式创建过滤器，请遵循以下规则：<br>有五个过滤条件，其中四个是限制。 它们是<code>maxarray</code>，<code>maxdepth</code>，<code>maxrefs</code>和<code>maxbytes</code>。 可以使用name = value来设置它们，其中name是这些关键字，value是限制。 如果模式包含等号（=），则模式必须使用这四个关键字作为名称。 第五个过滤条件用于指定类名形式的模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;module-name&gt;/&lt;fully-qualified-class-name&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果一个类是未命名的模块，则该模式将与类名匹配。 如果对象是一个数组，则数组的组件类型的类名用于匹配模式，而不是数组本身的类名。 以下是匹配类名称的模式的所有规则：</li>
<li>如果类名与模式匹配，则允许对象反序列化。</li>
<li>以“！” 模式开头的字符被视为逻辑NOT。</li>
<li>如果模式包含斜杠（/），斜杠之前的部分是模块名称。 如果模块名称与类的模块名称相匹配，则斜线后面的部分将被用作匹配类名称的模式。 如果模式中没有斜线，则在匹配模式时不考虑类的模块名称。</li>
<li>以“.**”结尾的模式匹配包中的任何类和所有子软件包。</li>
<li>以“.*”结尾的模式匹配包中的任何类。</li>
<li>以“*”结尾的模式匹配任何具有模式作为前缀的类。</li>
<li>如果模式等于类名称，则它匹配。</li>
<li>另外，模式不匹配，对象被拒绝。</li>
<li>如果将com.jdojo.<strong>设置为过滤器模式，它允许com.jdojo包中的所有类及其子包都被反序列化，并将拒绝所有其他类的反序列化对象。 如果将“com.jdojo.</strong>”设置为过滤器模式，它将拒绝com.jdojo包中的所有类及其子包以进行反序列化，并允许反序列化所有其他类的对象。</li>
</ul>
<p><code>getSerialFilter()</code>和<code>setSerialFilter()</code>方法用于获取和设置全局过滤器。 可以使用以下三种方式之一设置全局过滤器：</p>
<p>通过设置名为<code>jdk.serialFilter</code>的系统属性，该属性的值是以分号分隔的一系列过滤器模式。<br>通过在java.security文件中设置一个存储在<code>JAVA_HOME\conf\security</code>目录中的<code>jdk.serialFilter</code>属性。 如果正在使用JDK运行程序，请将JAVA_HOME作为JDK_HOME读取。 否则，将其读为JRE_HOME。<br>通过调用<code>ObjectInputFilter.Config</code>类的<code>setSerialFilter()</code>静态方法。<br>以下命令在运行类时将jdk.series属性设置为命令行选项。 不要担心这个命令的其他细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Java9Revealed&gt;java -Djdk.serialFilter=maxarray=100;maxdepth=3;com.jdojo.** --module-path com.jdojo.misc\build\classes --module com.jdojo.misc/com.jdojo.misc.ObjectFilterTest</span><br></pre></td></tr></table></figure>
<p>下面显示了<code>JAVA_HOME\conf\security\java.security</code>配置文件的部分内容。 该文件包含更多的条目。 只显示一个设置过滤器的条目，这与设置jdk.serialFilter系统属性具有相同的效果，如上一个命令所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxarray=100;maxdepth=3;com.jdojo.**</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips</p>
<p>如果在系统属性和配置文件中设置过滤器，则优先使用系统属性中的值。</p>
</blockquote>
<p>当运行具有全局过滤器的java命令时，会注意到stderr上的消息类似于此处显示的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Feb 17, 2017 9:23:45 AM java.io.ObjectInputFilter$Config lambda$static$0</span><br><span class="line">INFO: Creating serialization filter from maxarray=20;maxdepth=3;!com.jdojo.**</span><br></pre></td></tr></table></figure>
<p>这些消息使用java.io.serialization的Logger作为平台消息记录java.base模块。 如果指定了平台Logger，这些消息将被记录到Logger中。 其中一条消息在系统属性或配置文件中打印全局过滤器集。</p>
<p>还可以使用ObjectInputFilter.Config类的静态setSerialFilter()方法在代码中设置全局过滤器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a filter</span></span><br><span class="line">String pattern = <span class="string">"maxarray=100;maxdepth=3;com.jdojo.**"</span>;</span><br><span class="line">ObjectInputFilter globalFilter = ObjectInputFilter.Config.createFilter(pattern);</span><br><span class="line"><span class="comment">// Set a global filter</span></span><br><span class="line">ObjectInputFilter.Config.setSerialFilter(globalFilter);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips</p>
<p>只能设置一次全局过滤器。 例如，如果使用jdk.serialFilter系统属性设置过滤器，则在代码中调用<code>Config.setSerialFiter()</code>将抛出IllegalStateException。 当使用<code>Config.setSerialFiter()</code>方法设置全局过滤器时，必须设置非空值过滤器。 存在这些规则，以确保在代码中无法覆盖使用系统属性或配置文件的全局过滤器集。</p>
</blockquote>
<p>可以使用<code>ObjectInputFilter.Config</code>类的静态<code>getSerialFilter()</code>方法获取全局过滤器，而不考虑过滤器的设置方式。 如果没有全局过滤器，则此方法返回null。</p>
<p>ObjectInputFilter.FilterInfo是一个嵌套的静态接口，其实例包装了反序列化的当前上下文。<code>ObjectInputFilter.FilterInfo</code>的实例被创建并传递给过滤器的checkInput()方法。 不必在程序中实现此接口并创建其实例。 该接口包含以下方法，将在自定义过滤器的<code>checkInput()</code>方法中使用以读取当前反序列化上下文：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; serialClass()</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">arrayLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">depth</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">references</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">streamBytes</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>serialClass()</code>方法返回反序列化对象的类。对于数组，它返回数组的类，而不是数组的组件类型的类。在反序列化期间未创建新对象时，此方法返回null。</p>
<p><code>arrayLength()</code>方法返回反序列化数组的长度。它被反序列化的对象不是数组，它返回-1。</p>
<p><code>depth()</code>方法返回被反序列化的对象的嵌套深度。它从1开始，对于每个嵌套级别递增1，当嵌套对象返回时，递减1。</p>
<p><code>references()</code>方法返回反序列化的对象引用的当前数量。</p>
<p><code>streamBytes()</code>方法返回从对象输入流消耗的当前字节数。</p>
<p>对象可能根据指定的过滤条件会通过，也可能会失败。根据测试结果，应该返回ObjectInputFilter.Status枚举的以下常量。通常，在自定义过滤器类的<code>checkInput()</code>方法中使用这些常量作为返回值。</p>
<ul>
<li>ALLOWED</li>
<li>REJECTED</li>
<li>UNDECIDED</li>
</ul>
<p>这些常量表示反序列化允许，拒绝和未定。 通常，返回UNDECIDED表示一些其他过滤器将决定当前对象的反序列化是否继续。 如果正在创建一个过滤器以将类列入黑名单，则可以返回REJECTED以获取黑名单类别的匹配项，而对其他类别则为UNDECIDED。</p>
<p>下面包含一个基于数组长度进行过滤的简单过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayLengthObjectFilter.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputFilter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayLengthObjectFilter</span> <span class="keyword">implements</span> <span class="title">ObjectInputFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxLenth = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayLengthObjectFilter</span><span class="params">(<span class="keyword">int</span> maxLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxLenth = maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">checkInput</span><span class="params">(FilterInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> arrayLength = info.arrayLength();</span><br><span class="line">        <span class="keyword">if</span> (arrayLength &gt;= <span class="number">0</span> &amp;&amp; arrayLength &gt; <span class="keyword">this</span>.maxLenth) &#123;</span><br><span class="line">            <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Status.ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下代码片段通过将数组的最大长度指定为3来使用自定义过滤器。如果对象输入流包含长度大于3的数组，则反序列化将失败，并显示java.io.InvalidClassException。 代码不显示异常处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayLengthObjectFilter filter = new ArrayLengthObjectFilter(3);</span><br><span class="line">File inputFile = ...</span><br><span class="line">ObjectInputStream in =  new ObjectInputStream(new FileInputStream(inputFile))) &#123;            </span><br><span class="line">in.setObjectInputFilter(filter);</span><br><span class="line">Object obj = in.readObject();</span><br></pre></td></tr></table></figure>
<p>下面包含一个Item类的代码。为保持代码简洁，省略了getter和setter方法。 使用它的对象来演示反序列化过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Item.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] points;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span>[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.points = points;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add getters and setters here */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", points="</span> + Arrays.toString(points) + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面包含ObjectFilterTest类的代码，用于演示在对象反序列化过程中使用过滤器。 代码中有详细的说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectFilterTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.jdojo.misc;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputFilter.Config;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectFilterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;         </span><br><span class="line">        <span class="comment">// Relative path of the output/input file</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"serialized"</span>, <span class="string">"item.ser"</span>);</span><br><span class="line">        <span class="comment">// Make sure directories exist</span></span><br><span class="line">        ensureParentDirExists(file);</span><br><span class="line">        <span class="comment">// Create an Item used in serialization and deserialization</span></span><br><span class="line">        Item item = <span class="keyword">new</span> Item(<span class="number">100</span>, <span class="string">"Pen"</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// Serialize the item</span></span><br><span class="line">        serialize(file, item);</span><br><span class="line">        <span class="comment">// Print the global filter</span></span><br><span class="line">        ObjectInputFilter globalFilter = Config.getSerialFilter();</span><br><span class="line">        System.out.println(<span class="string">"Global filter: "</span> + globalFilter);</span><br><span class="line">        <span class="comment">// Deserialize the item</span></span><br><span class="line">        Item item2 = deserialize(file);</span><br><span class="line">        System.out.println(<span class="string">"Deserialized using global filter: "</span> + item2);</span><br><span class="line">        <span class="comment">// Use a filter to reject array size &gt; 2</span></span><br><span class="line">        String maxArrayFilterPattern = <span class="string">"maxarray=2"</span>;</span><br><span class="line">        ObjectInputFilter maxArrayFilter = Config.createFilter(maxArrayFilterPattern);         </span><br><span class="line">        Item item3 = deserialize(file, maxArrayFilter);</span><br><span class="line">        System.out.println(<span class="string">"Deserialized with a maxarray=2 filter: "</span> + item3);</span><br><span class="line">        <span class="comment">// Create a custom filter</span></span><br><span class="line">        ArrayLengthObjectFilter customFilter = <span class="keyword">new</span> ArrayLengthObjectFilter(<span class="number">5</span>);                </span><br><span class="line">        Item item4 = deserialize(file, customFilter);</span><br><span class="line">        System.out.println(<span class="string">"Deserialized with a custom filter (maxarray=5): "</span> + item4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(File file, Item item)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream out =  <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file))) &#123;            </span><br><span class="line">            out.writeObject(item);</span><br><span class="line">            System.out.println(<span class="string">"Serialized Item: "</span> + item);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Item <span class="title">deserialize</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream in =  <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;                        </span><br><span class="line">            Item item = (Item)in.readObject();</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not deserialize item. Error: "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Item <span class="title">deserialize</span><span class="params">(File file, ObjectInputFilter filter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream in =  <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;            </span><br><span class="line">            <span class="comment">// Set the object input filter passed in</span></span><br><span class="line">            in.setObjectInputFilter(filter);</span><br><span class="line">            Item item = (Item)in.readObject();</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not deserialize item. Error: "</span> + e.getMessage());            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureParentDirExists</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        File parent = file.getParentFile();</span><br><span class="line">        <span class="keyword">if</span>(!parent.exists()) &#123;</span><br><span class="line">            parent.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Input/output file is "</span> + file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObjectFilterTest使用不同的过滤器序列化Item类，随后使用相同Item类多个反序列化。<code>ensureParentDirExists()</code>方法接受一个文件，并确保其父目录存在，如果需要创建它。 该目录还打印序列化文件的路径。</p>
<p><code>serialize()</code>方法将指定的Item对象序列化为指定的文件。 这个方法从<code>main()</code>方法调用一次序列化一个Item对象。</p>
<p><code>deserialize()</code>方法是重载的。 <code>deserialize(File file)</code>版本使用全局过滤器（如果有的话）反序列化保存在指定文件中的Item对象。 <code>deserialize(File file, ObjectInputFilter filter)</code>版本使用指定的过滤器反序列化保存在指定文件中的Item对象。 注意在此方法中使用<code>in.setObjectInputFilter(filter)</code>方法调用。 它为ObjectInputStream设置指定的过滤器。 此过滤器将覆盖全局过滤器（如果有）。</p>
<p><code>main()</code>方法打印全局过滤器，创建一个Item对象并对其进行序列化，创建多个本地过滤器，并使用不同的过滤器对同一个Item对象进行反序列化。 以下命令运行ObjectFilterTest类而不使用全局过滤器。 可能得到不同的输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Java9Revealed&gt;java --module-path com.jdojo.misc\build\classes</span><br><span class="line">--module com.jdojo.misc/com.jdojo.misc.ObjectFilterTest</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input/output file is C:\Java9Revealed\serialized\item.ser</span><br><span class="line">Serialized Item: [id=100, name=Pen, points=[1, 2, 3, 4]]</span><br><span class="line">Global filter: null</span><br><span class="line">Deserialized using global filter: [id=100, name=Pen, points=[1, 2, 3, 4]]</span><br><span class="line">Could not deserialize item. Error: filter status: REJECTED</span><br><span class="line">Deserialized with a maxarray=2 filter: null</span><br><span class="line">Deserialized with a custom filter (maxarray=2): [id=100, name=Pen, points=[1, 2, 3, 4]]</span><br></pre></td></tr></table></figure>
<p>以下命令使用全局过滤器maxarray = 1运行ObjectFilterTest类，这将防止具有多个元素的数组被反序列化。 全局过滤器是使用jdk.serialFilter系统属性设置的。 因为正在使用全局过滤器，JDK类将在stderr上记录消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Java9Revealed&gt;java -Djdk.serialFilter=maxarray=1</span><br><span class="line">--module-path com.jdojo.misc\build\classes</span><br><span class="line">--module com.jdojo.misc/com.jdojo.misc.ObjectFilterTest</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input/output file is C:\Java9Revealed\serialized\item.ser</span><br><span class="line">Serialized Item: [id=100, name=Pen, points=[1, 2, 3, 4]]</span><br><span class="line">Feb 17, 2017 1:09:57 PM java.io.ObjectInputFilter$Config lambda$static$0</span><br><span class="line">INFO: Creating serialization filter from maxarray=1</span><br><span class="line">Global filter: maxarray=1</span><br><span class="line">Could not deserialize item. Error: filter status: REJECTED</span><br><span class="line">Deserialized using global filter: null</span><br><span class="line">Could not deserialize item. Error: filter status: REJECTED</span><br><span class="line">Deserialized with a maxarray=2 filter: null</span><br><span class="line">Deserialized with a custom filter (maxarray=5): [id=100, name=Pen, points=[1, 2, 3, 4]]</span><br></pre></td></tr></table></figure>
<p>注意使用全局过滤器时的输出。 因为Item对象包含一个包含四个元素的数组，所以全局过滤器阻止它反序列化。 但是，可以使用ArrayLengthObjectFilter对同一对象进行反序列化，因为此过滤器覆盖全局过滤器，并允许数组中最多有五个元素。 这在输出的最后一行是显而易见的。</p>
<h2 id="二十一-Java-I-O-API新增方法"><a href="#二十一-Java-I-O-API新增方法" class="headerlink" title="二十一. Java I/O API新增方法"></a>二十一. Java I/O API新增方法</h2><p>JDK 9向I/O API添加了一些方便的方法。 第一个是InputStream类中的一种新方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>编写的代码从输入流读取所有字节，以便写入输出流。 现在，不必编写一个循环来从输入流读取字节并将其写入输出流。 <code>transferTo()</code>方法从输入流读取所有字节，并将它们读取时依次写入指定的输出流。 该方法返回传输的字节数。</p>
<blockquote>
<p>Tips</p>
<p>transferTo()方法不会关闭任何一个流。 当此方法返回时，输入流将在流的末尾。</p>
</blockquote>
<p>忽略异常处理和流关闭逻辑，这里是一行代码，将log.txt文件的内容复制到log_copy.txt文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FileInputStream(<span class="string">"log.txt"</span>).transferTo(<span class="keyword">new</span> FileOutputStream(<span class="string">"log_copy.txt"</span>));</span><br></pre></td></tr></table></figure>
<p>java.nio.Buffer类在JDK 9中增加了两种新方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> Buffer <span class="title">duplicate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> Buffer <span class="title">slice</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>两种方法返回一个Buffer，它共享原始缓冲区的内容。 仅当原始缓冲区是直接的或只读时，返回的缓冲区将是直接的或只读的。 <code>duplicate()</code>方法返回一个缓冲区，其容量，临界，位置和标记值将与原始缓冲区的值相同。 <code>slice()</code>方法返回一个缓冲区，其位置将为零，容量和临界是此缓冲区中剩余的元素数量，标记不定义。 返回的缓冲区的内容从原始缓冲区的当前位置开始。 来自这些方法的返回缓冲区保持与原始缓冲区无关的位置，限定和标记。 以下代码片段显示了duplicated和sliced缓冲区的特征：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IntBuffer b1 = IntBuffer.wrap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">IntBuffer b2 = b1.duplicate();</span><br><span class="line">IntBuffer b3 = b1.slice();</span><br><span class="line">System.out.println(<span class="string">"b1="</span> + b1);</span><br><span class="line">System.out.println(<span class="string">"b2="</span> + b2);</span><br><span class="line">System.out.println(<span class="string">"b2="</span> + b3);</span><br><span class="line"><span class="comment">// Move b1 y 1 pos</span></span><br><span class="line">b1.get();</span><br><span class="line">IntBuffer b4 = b1.duplicate();</span><br><span class="line">IntBuffer b5 = b1.slice();</span><br><span class="line">System.out.println(<span class="string">"b1="</span> + b1);</span><br><span class="line">System.out.println(<span class="string">"b4="</span> + b4);</span><br><span class="line">System.out.println(<span class="string">"b5="</span> + b5);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b1=java.nio.HeapIntBuffer[pos=0 lim=4 cap=4]</span><br><span class="line">b2=java.nio.HeapIntBuffer[pos=0 lim=4 cap=4]</span><br><span class="line">b2=java.nio.HeapIntBuffer[pos=0 lim=4 cap=4]</span><br><span class="line">b1=java.nio.HeapIntBuffer[pos=1 lim=4 cap=4]</span><br><span class="line">b4=java.nio.HeapIntBuffer[pos=1 lim=4 cap=4]</span><br><span class="line">b5=java.nio.HeapIntBuffer[pos=0 lim=3 cap=3]</span><br></pre></td></tr></table></figure>
</div><p class="readmore"><a href="http://blog.oneforce.cn/online-markdown/?path=https://raw.githubusercontent.com/oneforce/oneforce.github.io/blog/source/_posts/Java/Java 9 Revealed/Chapter 20 JDK 9中API层次的改变.md">在微信markdown中展示</a></p><div class="tags"><a href="/tags/Java9/">Java9</a></div><div class="post-nav"><a class="pre" href="/2018/04/19/Java/Java 9 Revealed/Chapter 16 虚拟机栈遍历/">虚拟机栈遍历</a><a class="next" href="/2018/04/19/Java/Java 9 Revealed/Chapter 19 平台和JVM日志/">平台和JVM日志</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="https://oneforce.github.io"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-9-Revealed/">Java 9 Revealed</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Revealed/">Java Revealed</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot2/">SpringBoot2</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/参考文档/">参考文档</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/征信/">征信</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/私募基金/">私募基金</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/资产管理/">资产管理</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/金融法规/">金融法规</a><span class="category-list-count">15</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/入门系列/" style="font-size: 15px;">入门系列</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/spring-boot/" style="font-size: 15px;">spring boot</a> <a href="/tags/合规/" style="font-size: 15px;">合规</a> <a href="/tags/征信/" style="font-size: 15px;">征信</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/utf8/" style="font-size: 15px;">utf8</a> <a href="/tags/字符集/" style="font-size: 15px;">字符集</a> <a href="/tags/上海/" style="font-size: 15px;">上海</a> <a href="/tags/汽车/" style="font-size: 15px;">汽车</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/svn/" style="font-size: 15px;">svn</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/金融/" style="font-size: 15px;">金融</a> <a href="/tags/上海市互联网金融行业协会/" style="font-size: 15px;">上海市互联网金融行业协会</a> <a href="/tags/网络借贷/" style="font-size: 15px;">网络借贷</a> <a href="/tags/P2P/" style="font-size: 15px;">P2P</a> <a href="/tags/金融办/" style="font-size: 15px;">金融办</a> <a href="/tags/2018/" style="font-size: 15px;">2018</a> <a href="/tags/指引/" style="font-size: 15px;">指引</a> <a href="/tags/电子合同存证/" style="font-size: 15px;">电子合同存证</a> <a href="/tags/金融科技/" style="font-size: 15px;">金融科技</a> <a href="/tags/银监会/" style="font-size: 15px;">银监会</a> <a href="/tags/资产管理/" style="font-size: 15px;">资产管理</a> <a href="/tags/现金贷/" style="font-size: 15px;">现金贷</a> <a href="/tags/Java9/" style="font-size: 15px;">Java9</a> <a href="/tags/stream/" style="font-size: 15px;">stream</a> <a href="/tags/long/" style="font-size: 15px;">long</a> <a href="/tags/Spring-Boot-2/" style="font-size: 15px;">Spring Boot 2</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a> <a href="/tags/原则/" style="font-size: 15px;">原则</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/央行/" style="font-size: 15px;">央行</a> <a href="/tags/代收/" style="font-size: 15px;">代收</a> <a href="/tags/p2p/" style="font-size: 15px;">p2p</a> <a href="/tags/证监会/" style="font-size: 15px;">证监会</a> <a href="/tags/私募基金/" style="font-size: 15px;">私募基金</a> <a href="/tags/PE/" style="font-size: 15px;">PE</a> <a href="/tags/委托贷款/" style="font-size: 15px;">委托贷款</a> <a href="/tags/私募/" style="font-size: 15px;">私募</a> <a href="/tags/jshell/" style="font-size: 15px;">jshell</a> <a href="/tags/collection/" style="font-size: 15px;">collection</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/http-2/" style="font-size: 15px;">http/2</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/fabric/" style="font-size: 15px;">fabric</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/说明文档/" style="font-size: 15px;">说明文档</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/10/04/金融/促进金融科技发展 支持上海建设金融科技中心/">金融/促进金融科技发展 支持上海建设金融科技中心</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/04/技术杂项/字符集和字符编码/">技术杂项/字符集和字符编码</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/13/说明/常用正则/">常用正则</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/技术杂项/架构/架构在做什么1/">架构在做什么1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/金融/中国人民银行/中国人民银行关于规范代收业务 的通知（征求意见稿）》主要问题说明/">《中国人民银行关于规范代收业务的通知（征求意见稿）》主要问题说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/金融/中国人民银行/中国人民银行关于规范代收业务的通知/">中国人民银行关于规范代收业务的通知 (征求意见稿)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/找书途径及下载方法/">找书途径及下载方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/金融/促进金融科技发展支持上海建设金融科技中心/">促进金融科技发展 支持上海建设金融科技中心</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/技术杂项/spring/设置context-path不能被服务发现的问题/">设置context-path不能被服务发现的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/21/金融/关于办理非法放贷刑事案件若干问题的意见/">关于办理非法放贷刑事案件若干问题的意见</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//oneforce-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">oneforce blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = '//hm.baidu.com/hm.js?' + '718da94a7cf34af2eac95661ab1fc06f';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script>(function () {
  var bp = document.createElement('script');
  bp.src = '//push.zhanzhang.baidu.com/push.js';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>